// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef PROTOBUF_INCLUDED_config_2eproto
#define PROTOBUF_INCLUDED_config_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_config_2eproto 

namespace protobuf_config_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_config_2eproto
namespace nsjail {
class Exe;
class ExeDefaultTypeInternal;
extern ExeDefaultTypeInternal _Exe_default_instance_;
class IdMap;
class IdMapDefaultTypeInternal;
extern IdMapDefaultTypeInternal _IdMap_default_instance_;
class MountPt;
class MountPtDefaultTypeInternal;
extern MountPtDefaultTypeInternal _MountPt_default_instance_;
class NsJailConfig;
class NsJailConfigDefaultTypeInternal;
extern NsJailConfigDefaultTypeInternal _NsJailConfig_default_instance_;
}  // namespace nsjail
namespace google {
namespace protobuf {
template<> ::nsjail::Exe* Arena::CreateMaybeMessage<::nsjail::Exe>(Arena*);
template<> ::nsjail::IdMap* Arena::CreateMaybeMessage<::nsjail::IdMap>(Arena*);
template<> ::nsjail::MountPt* Arena::CreateMaybeMessage<::nsjail::MountPt>(Arena*);
template<> ::nsjail::NsJailConfig* Arena::CreateMaybeMessage<::nsjail::NsJailConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nsjail {

enum Mode {
  LISTEN = 0,
  ONCE = 1,
  RERUN = 2,
  EXECVE = 3
};
bool Mode_IsValid(int value);
const Mode Mode_MIN = LISTEN;
const Mode Mode_MAX = EXECVE;
const int Mode_ARRAYSIZE = Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mode_descriptor();
inline const ::std::string& Mode_Name(Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mode_descriptor(), value);
}
inline bool Mode_Parse(
    const ::std::string& name, Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mode>(
    Mode_descriptor(), name, value);
}
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARNING = 2,
  ERROR = 3,
  FATAL = 4
};
bool LogLevel_IsValid(int value);
const LogLevel LogLevel_MIN = DEBUG;
const LogLevel LogLevel_MAX = FATAL;
const int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogLevel_descriptor();
inline const ::std::string& LogLevel_Name(LogLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogLevel_descriptor(), value);
}
inline bool LogLevel_Parse(
    const ::std::string& name, LogLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum RLimit {
  VALUE = 0,
  SOFT = 1,
  HARD = 2,
  INF = 3
};
bool RLimit_IsValid(int value);
const RLimit RLimit_MIN = VALUE;
const RLimit RLimit_MAX = INF;
const int RLimit_ARRAYSIZE = RLimit_MAX + 1;

const ::google::protobuf::EnumDescriptor* RLimit_descriptor();
inline const ::std::string& RLimit_Name(RLimit value) {
  return ::google::protobuf::internal::NameOfEnum(
    RLimit_descriptor(), value);
}
inline bool RLimit_Parse(
    const ::std::string& name, RLimit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RLimit>(
    RLimit_descriptor(), name, value);
}
// ===================================================================

class IdMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsjail.IdMap) */ {
 public:
  IdMap();
  virtual ~IdMap();

  IdMap(const IdMap& from);

  inline IdMap& operator=(const IdMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IdMap(IdMap&& from) noexcept
    : IdMap() {
    *this = ::std::move(from);
  }

  inline IdMap& operator=(IdMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IdMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IdMap* internal_default_instance() {
    return reinterpret_cast<const IdMap*>(
               &_IdMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(IdMap* other);
  friend void swap(IdMap& a, IdMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IdMap* New() const final {
    return CreateMaybeMessage<IdMap>(NULL);
  }

  IdMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IdMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IdMap& from);
  void MergeFrom(const IdMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string inside_id = 1 [default = ""];
  bool has_inside_id() const;
  void clear_inside_id();
  static const int kInsideIdFieldNumber = 1;
  const ::std::string& inside_id() const;
  void set_inside_id(const ::std::string& value);
  #if LANG_CXX11
  void set_inside_id(::std::string&& value);
  #endif
  void set_inside_id(const char* value);
  void set_inside_id(const char* value, size_t size);
  ::std::string* mutable_inside_id();
  ::std::string* release_inside_id();
  void set_allocated_inside_id(::std::string* inside_id);

  // optional string outside_id = 2 [default = ""];
  bool has_outside_id() const;
  void clear_outside_id();
  static const int kOutsideIdFieldNumber = 2;
  const ::std::string& outside_id() const;
  void set_outside_id(const ::std::string& value);
  #if LANG_CXX11
  void set_outside_id(::std::string&& value);
  #endif
  void set_outside_id(const char* value);
  void set_outside_id(const char* value, size_t size);
  ::std::string* mutable_outside_id();
  ::std::string* release_outside_id();
  void set_allocated_outside_id(::std::string* outside_id);

  // optional bool use_newidmap = 4 [default = false];
  bool has_use_newidmap() const;
  void clear_use_newidmap();
  static const int kUseNewidmapFieldNumber = 4;
  bool use_newidmap() const;
  void set_use_newidmap(bool value);

  // optional uint32 count = 3 [default = 1];
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nsjail.IdMap)
 private:
  void set_has_inside_id();
  void clear_has_inside_id();
  void set_has_outside_id();
  void clear_has_outside_id();
  void set_has_count();
  void clear_has_count();
  void set_has_use_newidmap();
  void clear_has_use_newidmap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr inside_id_;
  ::google::protobuf::internal::ArenaStringPtr outside_id_;
  bool use_newidmap_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MountPt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsjail.MountPt) */ {
 public:
  MountPt();
  virtual ~MountPt();

  MountPt(const MountPt& from);

  inline MountPt& operator=(const MountPt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MountPt(MountPt&& from) noexcept
    : MountPt() {
    *this = ::std::move(from);
  }

  inline MountPt& operator=(MountPt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MountPt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MountPt* internal_default_instance() {
    return reinterpret_cast<const MountPt*>(
               &_MountPt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MountPt* other);
  friend void swap(MountPt& a, MountPt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MountPt* New() const final {
    return CreateMaybeMessage<MountPt>(NULL);
  }

  MountPt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MountPt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MountPt& from);
  void MergeFrom(const MountPt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MountPt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string src = 1 [default = ""];
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::std::string& src() const;
  void set_src(const ::std::string& value);
  #if LANG_CXX11
  void set_src(::std::string&& value);
  #endif
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  ::std::string* mutable_src();
  ::std::string* release_src();
  void set_allocated_src(::std::string* src);

  // optional string prefix_src_env = 2 [default = ""];
  bool has_prefix_src_env() const;
  void clear_prefix_src_env();
  static const int kPrefixSrcEnvFieldNumber = 2;
  const ::std::string& prefix_src_env() const;
  void set_prefix_src_env(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix_src_env(::std::string&& value);
  #endif
  void set_prefix_src_env(const char* value);
  void set_prefix_src_env(const char* value, size_t size);
  ::std::string* mutable_prefix_src_env();
  ::std::string* release_prefix_src_env();
  void set_allocated_prefix_src_env(::std::string* prefix_src_env);

  // optional bytes src_content = 3 [default = ""];
  bool has_src_content() const;
  void clear_src_content();
  static const int kSrcContentFieldNumber = 3;
  const ::std::string& src_content() const;
  void set_src_content(const ::std::string& value);
  #if LANG_CXX11
  void set_src_content(::std::string&& value);
  #endif
  void set_src_content(const char* value);
  void set_src_content(const void* value, size_t size);
  ::std::string* mutable_src_content();
  ::std::string* release_src_content();
  void set_allocated_src_content(::std::string* src_content);

  // required string dst = 4 [default = ""];
  bool has_dst() const;
  void clear_dst();
  static const int kDstFieldNumber = 4;
  const ::std::string& dst() const;
  void set_dst(const ::std::string& value);
  #if LANG_CXX11
  void set_dst(::std::string&& value);
  #endif
  void set_dst(const char* value);
  void set_dst(const char* value, size_t size);
  ::std::string* mutable_dst();
  ::std::string* release_dst();
  void set_allocated_dst(::std::string* dst);

  // optional string prefix_dst_env = 5 [default = ""];
  bool has_prefix_dst_env() const;
  void clear_prefix_dst_env();
  static const int kPrefixDstEnvFieldNumber = 5;
  const ::std::string& prefix_dst_env() const;
  void set_prefix_dst_env(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix_dst_env(::std::string&& value);
  #endif
  void set_prefix_dst_env(const char* value);
  void set_prefix_dst_env(const char* value, size_t size);
  ::std::string* mutable_prefix_dst_env();
  ::std::string* release_prefix_dst_env();
  void set_allocated_prefix_dst_env(::std::string* prefix_dst_env);

  // optional string fstype = 6 [default = ""];
  bool has_fstype() const;
  void clear_fstype();
  static const int kFstypeFieldNumber = 6;
  const ::std::string& fstype() const;
  void set_fstype(const ::std::string& value);
  #if LANG_CXX11
  void set_fstype(::std::string&& value);
  #endif
  void set_fstype(const char* value);
  void set_fstype(const char* value, size_t size);
  ::std::string* mutable_fstype();
  ::std::string* release_fstype();
  void set_allocated_fstype(::std::string* fstype);

  // optional string options = 7 [default = ""];
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 7;
  const ::std::string& options() const;
  void set_options(const ::std::string& value);
  #if LANG_CXX11
  void set_options(::std::string&& value);
  #endif
  void set_options(const char* value);
  void set_options(const char* value, size_t size);
  ::std::string* mutable_options();
  ::std::string* release_options();
  void set_allocated_options(::std::string* options);

  // optional bool is_bind = 8 [default = false];
  bool has_is_bind() const;
  void clear_is_bind();
  static const int kIsBindFieldNumber = 8;
  bool is_bind() const;
  void set_is_bind(bool value);

  // optional bool rw = 9 [default = false];
  bool has_rw() const;
  void clear_rw();
  static const int kRwFieldNumber = 9;
  bool rw() const;
  void set_rw(bool value);

  // optional bool is_dir = 10;
  bool has_is_dir() const;
  void clear_is_dir();
  static const int kIsDirFieldNumber = 10;
  bool is_dir() const;
  void set_is_dir(bool value);

  // optional bool is_symlink = 12 [default = false];
  bool has_is_symlink() const;
  void clear_is_symlink();
  static const int kIsSymlinkFieldNumber = 12;
  bool is_symlink() const;
  void set_is_symlink(bool value);

  // optional bool nosuid = 13 [default = false];
  bool has_nosuid() const;
  void clear_nosuid();
  static const int kNosuidFieldNumber = 13;
  bool nosuid() const;
  void set_nosuid(bool value);

  // optional bool nodev = 14 [default = false];
  bool has_nodev() const;
  void clear_nodev();
  static const int kNodevFieldNumber = 14;
  bool nodev() const;
  void set_nodev(bool value);

  // optional bool noexec = 15 [default = false];
  bool has_noexec() const;
  void clear_noexec();
  static const int kNoexecFieldNumber = 15;
  bool noexec() const;
  void set_noexec(bool value);

  // optional bool mandatory = 11 [default = true];
  bool has_mandatory() const;
  void clear_mandatory();
  static const int kMandatoryFieldNumber = 11;
  bool mandatory() const;
  void set_mandatory(bool value);

  // @@protoc_insertion_point(class_scope:nsjail.MountPt)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_prefix_src_env();
  void clear_has_prefix_src_env();
  void set_has_src_content();
  void clear_has_src_content();
  void set_has_dst();
  void clear_has_dst();
  void set_has_prefix_dst_env();
  void clear_has_prefix_dst_env();
  void set_has_fstype();
  void clear_has_fstype();
  void set_has_options();
  void clear_has_options();
  void set_has_is_bind();
  void clear_has_is_bind();
  void set_has_rw();
  void clear_has_rw();
  void set_has_is_dir();
  void clear_has_is_dir();
  void set_has_mandatory();
  void clear_has_mandatory();
  void set_has_is_symlink();
  void clear_has_is_symlink();
  void set_has_nosuid();
  void clear_has_nosuid();
  void set_has_nodev();
  void clear_has_nodev();
  void set_has_noexec();
  void clear_has_noexec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_;
  ::google::protobuf::internal::ArenaStringPtr prefix_src_env_;
  ::google::protobuf::internal::ArenaStringPtr src_content_;
  ::google::protobuf::internal::ArenaStringPtr dst_;
  ::google::protobuf::internal::ArenaStringPtr prefix_dst_env_;
  ::google::protobuf::internal::ArenaStringPtr fstype_;
  ::google::protobuf::internal::ArenaStringPtr options_;
  bool is_bind_;
  bool rw_;
  bool is_dir_;
  bool is_symlink_;
  bool nosuid_;
  bool nodev_;
  bool noexec_;
  bool mandatory_;
  friend struct ::protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Exe : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsjail.Exe) */ {
 public:
  Exe();
  virtual ~Exe();

  Exe(const Exe& from);

  inline Exe& operator=(const Exe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Exe(Exe&& from) noexcept
    : Exe() {
    *this = ::std::move(from);
  }

  inline Exe& operator=(Exe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Exe* internal_default_instance() {
    return reinterpret_cast<const Exe*>(
               &_Exe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Exe* other);
  friend void swap(Exe& a, Exe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Exe* New() const final {
    return CreateMaybeMessage<Exe>(NULL);
  }

  Exe* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Exe>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Exe& from);
  void MergeFrom(const Exe& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Exe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string arg = 2;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 2;
  const ::std::string& arg(int index) const;
  ::std::string* mutable_arg(int index);
  void set_arg(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_arg(int index, ::std::string&& value);
  #endif
  void set_arg(int index, const char* value);
  void set_arg(int index, const char* value, size_t size);
  ::std::string* add_arg();
  void add_arg(const ::std::string& value);
  #if LANG_CXX11
  void add_arg(::std::string&& value);
  #endif
  void add_arg(const char* value);
  void add_arg(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& arg() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_arg();

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional string arg0 = 3;
  bool has_arg0() const;
  void clear_arg0();
  static const int kArg0FieldNumber = 3;
  const ::std::string& arg0() const;
  void set_arg0(const ::std::string& value);
  #if LANG_CXX11
  void set_arg0(::std::string&& value);
  #endif
  void set_arg0(const char* value);
  void set_arg0(const char* value, size_t size);
  ::std::string* mutable_arg0();
  ::std::string* release_arg0();
  void set_allocated_arg0(::std::string* arg0);

  // optional bool exec_fd = 4 [default = false];
  bool has_exec_fd() const;
  void clear_exec_fd();
  static const int kExecFdFieldNumber = 4;
  bool exec_fd() const;
  void set_exec_fd(bool value);

  // @@protoc_insertion_point(class_scope:nsjail.Exe)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_arg0();
  void clear_has_arg0();
  void set_has_exec_fd();
  void clear_has_exec_fd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> arg_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr arg0_;
  bool exec_fd_;
  friend struct ::protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NsJailConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsjail.NsJailConfig) */ {
 public:
  NsJailConfig();
  virtual ~NsJailConfig();

  NsJailConfig(const NsJailConfig& from);

  inline NsJailConfig& operator=(const NsJailConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NsJailConfig(NsJailConfig&& from) noexcept
    : NsJailConfig() {
    *this = ::std::move(from);
  }

  inline NsJailConfig& operator=(NsJailConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NsJailConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NsJailConfig* internal_default_instance() {
    return reinterpret_cast<const NsJailConfig*>(
               &_NsJailConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NsJailConfig* other);
  friend void swap(NsJailConfig& a, NsJailConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NsJailConfig* New() const final {
    return CreateMaybeMessage<NsJailConfig>(NULL);
  }

  NsJailConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NsJailConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NsJailConfig& from);
  void MergeFrom(const NsJailConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NsJailConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string description = 2;
  int description_size() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description(int index) const;
  ::std::string* mutable_description(int index);
  void set_description(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_description(int index, ::std::string&& value);
  #endif
  void set_description(int index, const char* value);
  void set_description(int index, const char* value, size_t size);
  ::std::string* add_description();
  void add_description(const ::std::string& value);
  #if LANG_CXX11
  void add_description(::std::string&& value);
  #endif
  void add_description(const char* value);
  void add_description(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& description() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_description();

  // repeated string envar = 18;
  int envar_size() const;
  void clear_envar();
  static const int kEnvarFieldNumber = 18;
  const ::std::string& envar(int index) const;
  ::std::string* mutable_envar(int index);
  void set_envar(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_envar(int index, ::std::string&& value);
  #endif
  void set_envar(int index, const char* value);
  void set_envar(int index, const char* value, size_t size);
  ::std::string* add_envar();
  void add_envar(const ::std::string& value);
  #if LANG_CXX11
  void add_envar(::std::string&& value);
  #endif
  void add_envar(const char* value);
  void add_envar(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& envar() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_envar();

  // repeated string cap = 20;
  int cap_size() const;
  void clear_cap();
  static const int kCapFieldNumber = 20;
  const ::std::string& cap(int index) const;
  ::std::string* mutable_cap(int index);
  void set_cap(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_cap(int index, ::std::string&& value);
  #endif
  void set_cap(int index, const char* value);
  void set_cap(int index, const char* value, size_t size);
  ::std::string* add_cap();
  void add_cap(const ::std::string& value);
  #if LANG_CXX11
  void add_cap(::std::string&& value);
  #endif
  void add_cap(const char* value);
  void add_cap(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& cap() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cap();

  // repeated int32 pass_fd = 24;
  int pass_fd_size() const;
  void clear_pass_fd();
  static const int kPassFdFieldNumber = 24;
  ::google::protobuf::int32 pass_fd(int index) const;
  void set_pass_fd(int index, ::google::protobuf::int32 value);
  void add_pass_fd(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pass_fd() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pass_fd();

  // repeated .nsjail.IdMap uidmap = 60;
  int uidmap_size() const;
  void clear_uidmap();
  static const int kUidmapFieldNumber = 60;
  ::nsjail::IdMap* mutable_uidmap(int index);
  ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap >*
      mutable_uidmap();
  const ::nsjail::IdMap& uidmap(int index) const;
  ::nsjail::IdMap* add_uidmap();
  const ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap >&
      uidmap() const;

  // repeated .nsjail.IdMap gidmap = 61;
  int gidmap_size() const;
  void clear_gidmap();
  static const int kGidmapFieldNumber = 61;
  ::nsjail::IdMap* mutable_gidmap(int index);
  ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap >*
      mutable_gidmap();
  const ::nsjail::IdMap& gidmap(int index) const;
  ::nsjail::IdMap* add_gidmap();
  const ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap >&
      gidmap() const;

  // repeated .nsjail.MountPt mount = 63;
  int mount_size() const;
  void clear_mount();
  static const int kMountFieldNumber = 63;
  ::nsjail::MountPt* mutable_mount(int index);
  ::google::protobuf::RepeatedPtrField< ::nsjail::MountPt >*
      mutable_mount();
  const ::nsjail::MountPt& mount(int index) const;
  ::nsjail::MountPt* add_mount();
  const ::google::protobuf::RepeatedPtrField< ::nsjail::MountPt >&
      mount() const;

  // repeated string seccomp_string = 65;
  int seccomp_string_size() const;
  void clear_seccomp_string();
  static const int kSeccompStringFieldNumber = 65;
  const ::std::string& seccomp_string(int index) const;
  ::std::string* mutable_seccomp_string(int index);
  void set_seccomp_string(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_seccomp_string(int index, ::std::string&& value);
  #endif
  void set_seccomp_string(int index, const char* value);
  void set_seccomp_string(int index, const char* value, size_t size);
  ::std::string* add_seccomp_string();
  void add_seccomp_string(const ::std::string& value);
  #if LANG_CXX11
  void add_seccomp_string(::std::string&& value);
  #endif
  void add_seccomp_string(const char* value);
  void add_seccomp_string(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& seccomp_string() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_seccomp_string();

  // repeated string iface_own = 82;
  int iface_own_size() const;
  void clear_iface_own();
  static const int kIfaceOwnFieldNumber = 82;
  const ::std::string& iface_own(int index) const;
  ::std::string* mutable_iface_own(int index);
  void set_iface_own(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_iface_own(int index, ::std::string&& value);
  #endif
  void set_iface_own(int index, const char* value);
  void set_iface_own(int index, const char* value, size_t size);
  ::std::string* add_iface_own();
  void add_iface_own(const ::std::string& value);
  #if LANG_CXX11
  void add_iface_own(::std::string&& value);
  #endif
  void add_iface_own(const char* value);
  void add_iface_own(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& iface_own() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_iface_own();

  // optional string name = 1 [default = ""];
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string hostname = 4 [default = "NSJAIL"];
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional string cwd = 5 [default = "/"];
  bool has_cwd() const;
  void clear_cwd();
  static const int kCwdFieldNumber = 5;
  const ::std::string& cwd() const;
  void set_cwd(const ::std::string& value);
  #if LANG_CXX11
  void set_cwd(::std::string&& value);
  #endif
  void set_cwd(const char* value);
  void set_cwd(const char* value, size_t size);
  ::std::string* mutable_cwd();
  ::std::string* release_cwd();
  void set_allocated_cwd(::std::string* cwd);

  // optional string bindhost = 8 [default = "::"];
  bool has_bindhost() const;
  void clear_bindhost();
  static const int kBindhostFieldNumber = 8;
  const ::std::string& bindhost() const;
  void set_bindhost(const ::std::string& value);
  #if LANG_CXX11
  void set_bindhost(::std::string&& value);
  #endif
  void set_bindhost(const char* value);
  void set_bindhost(const char* value, size_t size);
  ::std::string* mutable_bindhost();
  ::std::string* release_bindhost();
  void set_allocated_bindhost(::std::string* bindhost);

  // optional string log_file = 15;
  bool has_log_file() const;
  void clear_log_file();
  static const int kLogFileFieldNumber = 15;
  const ::std::string& log_file() const;
  void set_log_file(const ::std::string& value);
  #if LANG_CXX11
  void set_log_file(::std::string&& value);
  #endif
  void set_log_file(const char* value);
  void set_log_file(const char* value, size_t size);
  ::std::string* mutable_log_file();
  ::std::string* release_log_file();
  void set_allocated_log_file(::std::string* log_file);

  // optional string seccomp_policy_file = 64;
  bool has_seccomp_policy_file() const;
  void clear_seccomp_policy_file();
  static const int kSeccompPolicyFileFieldNumber = 64;
  const ::std::string& seccomp_policy_file() const;
  void set_seccomp_policy_file(const ::std::string& value);
  #if LANG_CXX11
  void set_seccomp_policy_file(::std::string&& value);
  #endif
  void set_seccomp_policy_file(const char* value);
  void set_seccomp_policy_file(const char* value, size_t size);
  ::std::string* mutable_seccomp_policy_file();
  ::std::string* release_seccomp_policy_file();
  void set_allocated_seccomp_policy_file(::std::string* seccomp_policy_file);

  // optional string cgroup_mem_mount = 68 [default = "/sys/fs/cgroup/memory"];
  bool has_cgroup_mem_mount() const;
  void clear_cgroup_mem_mount();
  static const int kCgroupMemMountFieldNumber = 68;
  const ::std::string& cgroup_mem_mount() const;
  void set_cgroup_mem_mount(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_mem_mount(::std::string&& value);
  #endif
  void set_cgroup_mem_mount(const char* value);
  void set_cgroup_mem_mount(const char* value, size_t size);
  ::std::string* mutable_cgroup_mem_mount();
  ::std::string* release_cgroup_mem_mount();
  void set_allocated_cgroup_mem_mount(::std::string* cgroup_mem_mount);

  // optional string cgroup_mem_parent = 69 [default = "NSJAIL"];
  bool has_cgroup_mem_parent() const;
  void clear_cgroup_mem_parent();
  static const int kCgroupMemParentFieldNumber = 69;
  const ::std::string& cgroup_mem_parent() const;
  void set_cgroup_mem_parent(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_mem_parent(::std::string&& value);
  #endif
  void set_cgroup_mem_parent(const char* value);
  void set_cgroup_mem_parent(const char* value, size_t size);
  ::std::string* mutable_cgroup_mem_parent();
  ::std::string* release_cgroup_mem_parent();
  void set_allocated_cgroup_mem_parent(::std::string* cgroup_mem_parent);

  // optional string cgroup_pids_mount = 71 [default = "/sys/fs/cgroup/pids"];
  bool has_cgroup_pids_mount() const;
  void clear_cgroup_pids_mount();
  static const int kCgroupPidsMountFieldNumber = 71;
  const ::std::string& cgroup_pids_mount() const;
  void set_cgroup_pids_mount(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_pids_mount(::std::string&& value);
  #endif
  void set_cgroup_pids_mount(const char* value);
  void set_cgroup_pids_mount(const char* value, size_t size);
  ::std::string* mutable_cgroup_pids_mount();
  ::std::string* release_cgroup_pids_mount();
  void set_allocated_cgroup_pids_mount(::std::string* cgroup_pids_mount);

  // optional string cgroup_pids_parent = 72 [default = "NSJAIL"];
  bool has_cgroup_pids_parent() const;
  void clear_cgroup_pids_parent();
  static const int kCgroupPidsParentFieldNumber = 72;
  const ::std::string& cgroup_pids_parent() const;
  void set_cgroup_pids_parent(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_pids_parent(::std::string&& value);
  #endif
  void set_cgroup_pids_parent(const char* value);
  void set_cgroup_pids_parent(const char* value, size_t size);
  ::std::string* mutable_cgroup_pids_parent();
  ::std::string* release_cgroup_pids_parent();
  void set_allocated_cgroup_pids_parent(::std::string* cgroup_pids_parent);

  // optional string cgroup_net_cls_mount = 74 [default = "/sys/fs/cgroup/net_cls"];
  bool has_cgroup_net_cls_mount() const;
  void clear_cgroup_net_cls_mount();
  static const int kCgroupNetClsMountFieldNumber = 74;
  const ::std::string& cgroup_net_cls_mount() const;
  void set_cgroup_net_cls_mount(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_net_cls_mount(::std::string&& value);
  #endif
  void set_cgroup_net_cls_mount(const char* value);
  void set_cgroup_net_cls_mount(const char* value, size_t size);
  ::std::string* mutable_cgroup_net_cls_mount();
  ::std::string* release_cgroup_net_cls_mount();
  void set_allocated_cgroup_net_cls_mount(::std::string* cgroup_net_cls_mount);

  // optional string cgroup_net_cls_parent = 75 [default = "NSJAIL"];
  bool has_cgroup_net_cls_parent() const;
  void clear_cgroup_net_cls_parent();
  static const int kCgroupNetClsParentFieldNumber = 75;
  const ::std::string& cgroup_net_cls_parent() const;
  void set_cgroup_net_cls_parent(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_net_cls_parent(::std::string&& value);
  #endif
  void set_cgroup_net_cls_parent(const char* value);
  void set_cgroup_net_cls_parent(const char* value, size_t size);
  ::std::string* mutable_cgroup_net_cls_parent();
  ::std::string* release_cgroup_net_cls_parent();
  void set_allocated_cgroup_net_cls_parent(::std::string* cgroup_net_cls_parent);

  // optional string cgroup_cpu_mount = 77 [default = "/sys/fs/cgroup/cpu"];
  bool has_cgroup_cpu_mount() const;
  void clear_cgroup_cpu_mount();
  static const int kCgroupCpuMountFieldNumber = 77;
  const ::std::string& cgroup_cpu_mount() const;
  void set_cgroup_cpu_mount(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_cpu_mount(::std::string&& value);
  #endif
  void set_cgroup_cpu_mount(const char* value);
  void set_cgroup_cpu_mount(const char* value, size_t size);
  ::std::string* mutable_cgroup_cpu_mount();
  ::std::string* release_cgroup_cpu_mount();
  void set_allocated_cgroup_cpu_mount(::std::string* cgroup_cpu_mount);

  // optional string cgroup_cpu_parent = 78 [default = "NSJAIL"];
  bool has_cgroup_cpu_parent() const;
  void clear_cgroup_cpu_parent();
  static const int kCgroupCpuParentFieldNumber = 78;
  const ::std::string& cgroup_cpu_parent() const;
  void set_cgroup_cpu_parent(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_cpu_parent(::std::string&& value);
  #endif
  void set_cgroup_cpu_parent(const char* value);
  void set_cgroup_cpu_parent(const char* value, size_t size);
  ::std::string* mutable_cgroup_cpu_parent();
  ::std::string* release_cgroup_cpu_parent();
  void set_allocated_cgroup_cpu_parent(::std::string* cgroup_cpu_parent);

  // optional string cgroupv2_mount = 79 [default = "/sys/fs/cgroup"];
  bool has_cgroupv2_mount() const;
  void clear_cgroupv2_mount();
  static const int kCgroupv2MountFieldNumber = 79;
  const ::std::string& cgroupv2_mount() const;
  void set_cgroupv2_mount(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroupv2_mount(::std::string&& value);
  #endif
  void set_cgroupv2_mount(const char* value);
  void set_cgroupv2_mount(const char* value, size_t size);
  ::std::string* mutable_cgroupv2_mount();
  ::std::string* release_cgroupv2_mount();
  void set_allocated_cgroupv2_mount(::std::string* cgroupv2_mount);

  // optional string macvlan_iface = 83;
  bool has_macvlan_iface() const;
  void clear_macvlan_iface();
  static const int kMacvlanIfaceFieldNumber = 83;
  const ::std::string& macvlan_iface() const;
  void set_macvlan_iface(const ::std::string& value);
  #if LANG_CXX11
  void set_macvlan_iface(::std::string&& value);
  #endif
  void set_macvlan_iface(const char* value);
  void set_macvlan_iface(const char* value, size_t size);
  ::std::string* mutable_macvlan_iface();
  ::std::string* release_macvlan_iface();
  void set_allocated_macvlan_iface(::std::string* macvlan_iface);

  // optional string macvlan_vs_ip = 84 [default = "192.168.0.2"];
  bool has_macvlan_vs_ip() const;
  void clear_macvlan_vs_ip();
  static const int kMacvlanVsIpFieldNumber = 84;
  const ::std::string& macvlan_vs_ip() const;
  void set_macvlan_vs_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_macvlan_vs_ip(::std::string&& value);
  #endif
  void set_macvlan_vs_ip(const char* value);
  void set_macvlan_vs_ip(const char* value, size_t size);
  ::std::string* mutable_macvlan_vs_ip();
  ::std::string* release_macvlan_vs_ip();
  void set_allocated_macvlan_vs_ip(::std::string* macvlan_vs_ip);

  // optional string macvlan_vs_nm = 85 [default = "255.255.255.0"];
  bool has_macvlan_vs_nm() const;
  void clear_macvlan_vs_nm();
  static const int kMacvlanVsNmFieldNumber = 85;
  const ::std::string& macvlan_vs_nm() const;
  void set_macvlan_vs_nm(const ::std::string& value);
  #if LANG_CXX11
  void set_macvlan_vs_nm(::std::string&& value);
  #endif
  void set_macvlan_vs_nm(const char* value);
  void set_macvlan_vs_nm(const char* value, size_t size);
  ::std::string* mutable_macvlan_vs_nm();
  ::std::string* release_macvlan_vs_nm();
  void set_allocated_macvlan_vs_nm(::std::string* macvlan_vs_nm);

  // optional string macvlan_vs_gw = 86 [default = "192.168.0.1"];
  bool has_macvlan_vs_gw() const;
  void clear_macvlan_vs_gw();
  static const int kMacvlanVsGwFieldNumber = 86;
  const ::std::string& macvlan_vs_gw() const;
  void set_macvlan_vs_gw(const ::std::string& value);
  #if LANG_CXX11
  void set_macvlan_vs_gw(::std::string&& value);
  #endif
  void set_macvlan_vs_gw(const char* value);
  void set_macvlan_vs_gw(const char* value, size_t size);
  ::std::string* mutable_macvlan_vs_gw();
  ::std::string* release_macvlan_vs_gw();
  void set_allocated_macvlan_vs_gw(::std::string* macvlan_vs_gw);

  // optional string macvlan_vs_ma = 87 [default = ""];
  bool has_macvlan_vs_ma() const;
  void clear_macvlan_vs_ma();
  static const int kMacvlanVsMaFieldNumber = 87;
  const ::std::string& macvlan_vs_ma() const;
  void set_macvlan_vs_ma(const ::std::string& value);
  #if LANG_CXX11
  void set_macvlan_vs_ma(::std::string&& value);
  #endif
  void set_macvlan_vs_ma(const char* value);
  void set_macvlan_vs_ma(const char* value, size_t size);
  ::std::string* mutable_macvlan_vs_ma();
  ::std::string* release_macvlan_vs_ma();
  void set_allocated_macvlan_vs_ma(::std::string* macvlan_vs_ma);

  // optional string macvlan_vs_mo = 88 [default = "private"];
  bool has_macvlan_vs_mo() const;
  void clear_macvlan_vs_mo();
  static const int kMacvlanVsMoFieldNumber = 88;
  const ::std::string& macvlan_vs_mo() const;
  void set_macvlan_vs_mo(const ::std::string& value);
  #if LANG_CXX11
  void set_macvlan_vs_mo(::std::string&& value);
  #endif
  void set_macvlan_vs_mo(const char* value);
  void set_macvlan_vs_mo(const char* value, size_t size);
  ::std::string* mutable_macvlan_vs_mo();
  ::std::string* release_macvlan_vs_mo();
  void set_allocated_macvlan_vs_mo(::std::string* macvlan_vs_mo);

  // optional .nsjail.Exe exec_bin = 90;
  bool has_exec_bin() const;
  void clear_exec_bin();
  static const int kExecBinFieldNumber = 90;
  private:
  const ::nsjail::Exe& _internal_exec_bin() const;
  public:
  const ::nsjail::Exe& exec_bin() const;
  ::nsjail::Exe* release_exec_bin();
  ::nsjail::Exe* mutable_exec_bin();
  void set_allocated_exec_bin(::nsjail::Exe* exec_bin);

  // optional uint32 port = 7 [default = 0];
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 7;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional uint32 max_conns = 9 [default = 0];
  bool has_max_conns() const;
  void clear_max_conns();
  static const int kMaxConnsFieldNumber = 9;
  ::google::protobuf::uint32 max_conns() const;
  void set_max_conns(::google::protobuf::uint32 value);

  // optional uint32 max_conns_per_ip = 10 [default = 0];
  bool has_max_conns_per_ip() const;
  void clear_max_conns_per_ip();
  static const int kMaxConnsPerIpFieldNumber = 10;
  ::google::protobuf::uint32 max_conns_per_ip() const;
  void set_max_conns_per_ip(::google::protobuf::uint32 value);

  // optional uint32 max_cpus = 13 [default = 0];
  bool has_max_cpus() const;
  void clear_max_cpus();
  static const int kMaxCpusFieldNumber = 13;
  ::google::protobuf::uint32 max_cpus() const;
  void set_max_cpus(::google::protobuf::uint32 value);

  // optional bool no_pivotroot = 6 [default = false];
  bool has_no_pivotroot() const;
  void clear_no_pivotroot();
  static const int kNoPivotrootFieldNumber = 6;
  bool no_pivotroot() const;
  void set_no_pivotroot(bool value);

  // optional bool daemon = 12 [default = false];
  bool has_daemon() const;
  void clear_daemon();
  static const int kDaemonFieldNumber = 12;
  bool daemon() const;
  void set_daemon(bool value);

  // optional bool keep_env = 17 [default = false];
  bool has_keep_env() const;
  void clear_keep_env();
  static const int kKeepEnvFieldNumber = 17;
  bool keep_env() const;
  void set_keep_env(bool value);

  // optional bool keep_caps = 19 [default = false];
  bool has_keep_caps() const;
  void clear_keep_caps();
  static const int kKeepCapsFieldNumber = 19;
  bool keep_caps() const;
  void set_keep_caps(bool value);

  // optional int32 log_fd = 14;
  bool has_log_fd() const;
  void clear_log_fd();
  static const int kLogFdFieldNumber = 14;
  ::google::protobuf::int32 log_fd() const;
  void set_log_fd(::google::protobuf::int32 value);

  // optional .nsjail.LogLevel log_level = 16;
  bool has_log_level() const;
  void clear_log_level();
  static const int kLogLevelFieldNumber = 16;
  ::nsjail::LogLevel log_level() const;
  void set_log_level(::nsjail::LogLevel value);

  // optional bool silent = 21 [default = false];
  bool has_silent() const;
  void clear_silent();
  static const int kSilentFieldNumber = 21;
  bool silent() const;
  void set_silent(bool value);

  // optional bool skip_setsid = 22 [default = false];
  bool has_skip_setsid() const;
  void clear_skip_setsid();
  static const int kSkipSetsidFieldNumber = 22;
  bool skip_setsid() const;
  void set_skip_setsid(bool value);

  // optional bool stderr_to_null = 23 [default = false];
  bool has_stderr_to_null() const;
  void clear_stderr_to_null();
  static const int kStderrToNullFieldNumber = 23;
  bool stderr_to_null() const;
  void set_stderr_to_null(bool value);

  // optional bool disable_no_new_privs = 25 [default = false];
  bool has_disable_no_new_privs() const;
  void clear_disable_no_new_privs();
  static const int kDisableNoNewPrivsFieldNumber = 25;
  bool disable_no_new_privs() const;
  void set_disable_no_new_privs(bool value);

  // optional uint64 rlimit_core = 28 [default = 0];
  bool has_rlimit_core() const;
  void clear_rlimit_core();
  static const int kRlimitCoreFieldNumber = 28;
  ::google::protobuf::uint64 rlimit_core() const;
  void set_rlimit_core(::google::protobuf::uint64 value);

  // optional .nsjail.RLimit rlimit_as_type = 27 [default = VALUE];
  bool has_rlimit_as_type() const;
  void clear_rlimit_as_type();
  static const int kRlimitAsTypeFieldNumber = 27;
  ::nsjail::RLimit rlimit_as_type() const;
  void set_rlimit_as_type(::nsjail::RLimit value);

  // optional .nsjail.RLimit rlimit_core_type = 29 [default = VALUE];
  bool has_rlimit_core_type() const;
  void clear_rlimit_core_type();
  static const int kRlimitCoreTypeFieldNumber = 29;
  ::nsjail::RLimit rlimit_core_type() const;
  void set_rlimit_core_type(::nsjail::RLimit value);

  // optional .nsjail.RLimit rlimit_cpu_type = 31 [default = VALUE];
  bool has_rlimit_cpu_type() const;
  void clear_rlimit_cpu_type();
  static const int kRlimitCpuTypeFieldNumber = 31;
  ::nsjail::RLimit rlimit_cpu_type() const;
  void set_rlimit_cpu_type(::nsjail::RLimit value);

  // optional .nsjail.RLimit rlimit_fsize_type = 33 [default = VALUE];
  bool has_rlimit_fsize_type() const;
  void clear_rlimit_fsize_type();
  static const int kRlimitFsizeTypeFieldNumber = 33;
  ::nsjail::RLimit rlimit_fsize_type() const;
  void set_rlimit_fsize_type(::nsjail::RLimit value);

  // optional uint64 rlimit_rtprio = 42 [default = 0];
  bool has_rlimit_rtprio() const;
  void clear_rlimit_rtprio();
  static const int kRlimitRtprioFieldNumber = 42;
  ::google::protobuf::uint64 rlimit_rtprio() const;
  void set_rlimit_rtprio(::google::protobuf::uint64 value);

  // optional .nsjail.RLimit rlimit_nofile_type = 35 [default = VALUE];
  bool has_rlimit_nofile_type() const;
  void clear_rlimit_nofile_type();
  static const int kRlimitNofileTypeFieldNumber = 35;
  ::nsjail::RLimit rlimit_nofile_type() const;
  void set_rlimit_nofile_type(::nsjail::RLimit value);

  // optional bool disable_rl = 46 [default = false];
  bool has_disable_rl() const;
  void clear_disable_rl();
  static const int kDisableRlFieldNumber = 46;
  bool disable_rl() const;
  void set_disable_rl(bool value);

  // optional bool persona_addr_compat_layout = 47 [default = false];
  bool has_persona_addr_compat_layout() const;
  void clear_persona_addr_compat_layout();
  static const int kPersonaAddrCompatLayoutFieldNumber = 47;
  bool persona_addr_compat_layout() const;
  void set_persona_addr_compat_layout(bool value);

  // optional bool persona_mmap_page_zero = 48 [default = false];
  bool has_persona_mmap_page_zero() const;
  void clear_persona_mmap_page_zero();
  static const int kPersonaMmapPageZeroFieldNumber = 48;
  bool persona_mmap_page_zero() const;
  void set_persona_mmap_page_zero(bool value);

  // optional bool persona_read_implies_exec = 49 [default = false];
  bool has_persona_read_implies_exec() const;
  void clear_persona_read_implies_exec();
  static const int kPersonaReadImpliesExecFieldNumber = 49;
  bool persona_read_implies_exec() const;
  void set_persona_read_implies_exec(bool value);

  // optional bool persona_addr_limit_3gb = 50 [default = false];
  bool has_persona_addr_limit_3gb() const;
  void clear_persona_addr_limit_3gb();
  static const int kPersonaAddrLimit3GbFieldNumber = 50;
  bool persona_addr_limit_3gb() const;
  void set_persona_addr_limit_3gb(bool value);

  // optional bool persona_addr_no_randomize = 51 [default = false];
  bool has_persona_addr_no_randomize() const;
  void clear_persona_addr_no_randomize();
  static const int kPersonaAddrNoRandomizeFieldNumber = 51;
  bool persona_addr_no_randomize() const;
  void set_persona_addr_no_randomize(bool value);

  // optional bool clone_newtime = 59 [default = false];
  bool has_clone_newtime() const;
  void clear_clone_newtime();
  static const int kCloneNewtimeFieldNumber = 59;
  bool clone_newtime() const;
  void set_clone_newtime(bool value);

  // optional bool mount_proc = 62 [default = false];
  bool has_mount_proc() const;
  void clear_mount_proc();
  static const int kMountProcFieldNumber = 62;
  bool mount_proc() const;
  void set_mount_proc(bool value);

  // optional uint32 cgroup_net_cls_classid = 73 [default = 0];
  bool has_cgroup_net_cls_classid() const;
  void clear_cgroup_net_cls_classid();
  static const int kCgroupNetClsClassidFieldNumber = 73;
  ::google::protobuf::uint32 cgroup_net_cls_classid() const;
  void set_cgroup_net_cls_classid(::google::protobuf::uint32 value);

  // optional uint64 cgroup_mem_max = 67 [default = 0];
  bool has_cgroup_mem_max() const;
  void clear_cgroup_mem_max();
  static const int kCgroupMemMaxFieldNumber = 67;
  ::google::protobuf::uint64 cgroup_mem_max() const;
  void set_cgroup_mem_max(::google::protobuf::uint64 value);

  // optional uint64 cgroup_pids_max = 70 [default = 0];
  bool has_cgroup_pids_max() const;
  void clear_cgroup_pids_max();
  static const int kCgroupPidsMaxFieldNumber = 70;
  ::google::protobuf::uint64 cgroup_pids_max() const;
  void set_cgroup_pids_max(::google::protobuf::uint64 value);

  // optional uint32 cgroup_cpu_ms_per_sec = 76 [default = 0];
  bool has_cgroup_cpu_ms_per_sec() const;
  void clear_cgroup_cpu_ms_per_sec();
  static const int kCgroupCpuMsPerSecFieldNumber = 76;
  ::google::protobuf::uint32 cgroup_cpu_ms_per_sec() const;
  void set_cgroup_cpu_ms_per_sec(::google::protobuf::uint32 value);

  // optional bool seccomp_log = 66 [default = false];
  bool has_seccomp_log() const;
  void clear_seccomp_log();
  static const int kSeccompLogFieldNumber = 66;
  bool seccomp_log() const;
  void set_seccomp_log(bool value);

  // optional bool use_cgroupv2 = 80 [default = false];
  bool has_use_cgroupv2() const;
  void clear_use_cgroupv2();
  static const int kUseCgroupv2FieldNumber = 80;
  bool use_cgroupv2() const;
  void set_use_cgroupv2(bool value);

  // optional bool iface_no_lo = 81 [default = false];
  bool has_iface_no_lo() const;
  void clear_iface_no_lo();
  static const int kIfaceNoLoFieldNumber = 81;
  bool iface_no_lo() const;
  void set_iface_no_lo(bool value);

  // optional bool disable_tsc = 93 [default = false];
  bool has_disable_tsc() const;
  void clear_disable_tsc();
  static const int kDisableTscFieldNumber = 93;
  bool disable_tsc() const;
  void set_disable_tsc(bool value);

  // optional uint64 cgroup_mem_memsw_max = 91 [default = 0];
  bool has_cgroup_mem_memsw_max() const;
  void clear_cgroup_mem_memsw_max();
  static const int kCgroupMemMemswMaxFieldNumber = 91;
  ::google::protobuf::uint64 cgroup_mem_memsw_max() const;
  void set_cgroup_mem_memsw_max(::google::protobuf::uint64 value);

  // optional bool forward_signals = 94 [default = false];
  bool has_forward_signals() const;
  void clear_forward_signals();
  static const int kForwardSignalsFieldNumber = 94;
  bool forward_signals() const;
  void set_forward_signals(bool value);

  // optional bool detect_cgroupv2 = 95 [default = false];
  bool has_detect_cgroupv2() const;
  void clear_detect_cgroupv2();
  static const int kDetectCgroupv2FieldNumber = 95;
  bool detect_cgroupv2() const;
  void set_detect_cgroupv2(bool value);

  // optional .nsjail.Mode mode = 3 [default = ONCE];
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::nsjail::Mode mode() const;
  void set_mode(::nsjail::Mode value);

  // optional uint32 time_limit = 11 [default = 600];
  bool has_time_limit() const;
  void clear_time_limit();
  static const int kTimeLimitFieldNumber = 11;
  ::google::protobuf::uint32 time_limit() const;
  void set_time_limit(::google::protobuf::uint32 value);

  // optional uint64 rlimit_as = 26 [default = 4096];
  bool has_rlimit_as() const;
  void clear_rlimit_as();
  static const int kRlimitAsFieldNumber = 26;
  ::google::protobuf::uint64 rlimit_as() const;
  void set_rlimit_as(::google::protobuf::uint64 value);

  // optional uint64 rlimit_cpu = 30 [default = 600];
  bool has_rlimit_cpu() const;
  void clear_rlimit_cpu();
  static const int kRlimitCpuFieldNumber = 30;
  ::google::protobuf::uint64 rlimit_cpu() const;
  void set_rlimit_cpu(::google::protobuf::uint64 value);

  // optional uint64 rlimit_fsize = 32 [default = 1];
  bool has_rlimit_fsize() const;
  void clear_rlimit_fsize();
  static const int kRlimitFsizeFieldNumber = 32;
  ::google::protobuf::uint64 rlimit_fsize() const;
  void set_rlimit_fsize(::google::protobuf::uint64 value);

  // optional uint64 rlimit_nofile = 34 [default = 32];
  bool has_rlimit_nofile() const;
  void clear_rlimit_nofile();
  static const int kRlimitNofileFieldNumber = 34;
  ::google::protobuf::uint64 rlimit_nofile() const;
  void set_rlimit_nofile(::google::protobuf::uint64 value);

  // optional uint64 rlimit_nproc = 36 [default = 1024];
  bool has_rlimit_nproc() const;
  void clear_rlimit_nproc();
  static const int kRlimitNprocFieldNumber = 36;
  ::google::protobuf::uint64 rlimit_nproc() const;
  void set_rlimit_nproc(::google::protobuf::uint64 value);

  // optional uint64 rlimit_stack = 38 [default = 8];
  bool has_rlimit_stack() const;
  void clear_rlimit_stack();
  static const int kRlimitStackFieldNumber = 38;
  ::google::protobuf::uint64 rlimit_stack() const;
  void set_rlimit_stack(::google::protobuf::uint64 value);

  // optional .nsjail.RLimit rlimit_nproc_type = 37 [default = SOFT];
  bool has_rlimit_nproc_type() const;
  void clear_rlimit_nproc_type();
  static const int kRlimitNprocTypeFieldNumber = 37;
  ::nsjail::RLimit rlimit_nproc_type() const;
  void set_rlimit_nproc_type(::nsjail::RLimit value);

  // optional .nsjail.RLimit rlimit_stack_type = 39 [default = SOFT];
  bool has_rlimit_stack_type() const;
  void clear_rlimit_stack_type();
  static const int kRlimitStackTypeFieldNumber = 39;
  ::nsjail::RLimit rlimit_stack_type() const;
  void set_rlimit_stack_type(::nsjail::RLimit value);

  // optional uint64 rlimit_memlock = 40 [default = 64];
  bool has_rlimit_memlock() const;
  void clear_rlimit_memlock();
  static const int kRlimitMemlockFieldNumber = 40;
  ::google::protobuf::uint64 rlimit_memlock() const;
  void set_rlimit_memlock(::google::protobuf::uint64 value);

  // optional .nsjail.RLimit rlimit_memlock_type = 41 [default = SOFT];
  bool has_rlimit_memlock_type() const;
  void clear_rlimit_memlock_type();
  static const int kRlimitMemlockTypeFieldNumber = 41;
  ::nsjail::RLimit rlimit_memlock_type() const;
  void set_rlimit_memlock_type(::nsjail::RLimit value);

  // optional .nsjail.RLimit rlimit_rtprio_type = 43 [default = SOFT];
  bool has_rlimit_rtprio_type() const;
  void clear_rlimit_rtprio_type();
  static const int kRlimitRtprioTypeFieldNumber = 43;
  ::nsjail::RLimit rlimit_rtprio_type() const;
  void set_rlimit_rtprio_type(::nsjail::RLimit value);

  // optional uint64 rlimit_msgqueue = 44 [default = 1024];
  bool has_rlimit_msgqueue() const;
  void clear_rlimit_msgqueue();
  static const int kRlimitMsgqueueFieldNumber = 44;
  ::google::protobuf::uint64 rlimit_msgqueue() const;
  void set_rlimit_msgqueue(::google::protobuf::uint64 value);

  // optional .nsjail.RLimit rlimit_msgqueue_type = 45 [default = SOFT];
  bool has_rlimit_msgqueue_type() const;
  void clear_rlimit_msgqueue_type();
  static const int kRlimitMsgqueueTypeFieldNumber = 45;
  ::nsjail::RLimit rlimit_msgqueue_type() const;
  void set_rlimit_msgqueue_type(::nsjail::RLimit value);

  // optional bool clone_newnet = 52 [default = true];
  bool has_clone_newnet() const;
  void clear_clone_newnet();
  static const int kCloneNewnetFieldNumber = 52;
  bool clone_newnet() const;
  void set_clone_newnet(bool value);

  // optional bool clone_newuser = 53 [default = true];
  bool has_clone_newuser() const;
  void clear_clone_newuser();
  static const int kCloneNewuserFieldNumber = 53;
  bool clone_newuser() const;
  void set_clone_newuser(bool value);

  // optional bool clone_newns = 54 [default = true];
  bool has_clone_newns() const;
  void clear_clone_newns();
  static const int kCloneNewnsFieldNumber = 54;
  bool clone_newns() const;
  void set_clone_newns(bool value);

  // optional bool clone_newpid = 55 [default = true];
  bool has_clone_newpid() const;
  void clear_clone_newpid();
  static const int kCloneNewpidFieldNumber = 55;
  bool clone_newpid() const;
  void set_clone_newpid(bool value);

  // optional bool clone_newipc = 56 [default = true];
  bool has_clone_newipc() const;
  void clear_clone_newipc();
  static const int kCloneNewipcFieldNumber = 56;
  bool clone_newipc() const;
  void set_clone_newipc(bool value);

  // optional bool clone_newuts = 57 [default = true];
  bool has_clone_newuts() const;
  void clear_clone_newuts();
  static const int kCloneNewutsFieldNumber = 57;
  bool clone_newuts() const;
  void set_clone_newuts(bool value);

  // optional bool clone_newcgroup = 58 [default = true];
  bool has_clone_newcgroup() const;
  void clear_clone_newcgroup();
  static const int kCloneNewcgroupFieldNumber = 58;
  bool clone_newcgroup() const;
  void set_clone_newcgroup(bool value);

  // optional int32 nice_level = 89 [default = 19];
  bool has_nice_level() const;
  void clear_nice_level();
  static const int kNiceLevelFieldNumber = 89;
  ::google::protobuf::int32 nice_level() const;
  void set_nice_level(::google::protobuf::int32 value);

  // optional int64 cgroup_mem_swap_max = 92 [default = -1];
  bool has_cgroup_mem_swap_max() const;
  void clear_cgroup_mem_swap_max();
  static const int kCgroupMemSwapMaxFieldNumber = 92;
  ::google::protobuf::int64 cgroup_mem_swap_max() const;
  void set_cgroup_mem_swap_max(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nsjail.NsJailConfig)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_mode();
  void clear_has_mode();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_cwd();
  void clear_has_cwd();
  void set_has_no_pivotroot();
  void clear_has_no_pivotroot();
  void set_has_port();
  void clear_has_port();
  void set_has_bindhost();
  void clear_has_bindhost();
  void set_has_max_conns();
  void clear_has_max_conns();
  void set_has_max_conns_per_ip();
  void clear_has_max_conns_per_ip();
  void set_has_time_limit();
  void clear_has_time_limit();
  void set_has_daemon();
  void clear_has_daemon();
  void set_has_max_cpus();
  void clear_has_max_cpus();
  void set_has_log_fd();
  void clear_has_log_fd();
  void set_has_log_file();
  void clear_has_log_file();
  void set_has_log_level();
  void clear_has_log_level();
  void set_has_keep_env();
  void clear_has_keep_env();
  void set_has_keep_caps();
  void clear_has_keep_caps();
  void set_has_silent();
  void clear_has_silent();
  void set_has_skip_setsid();
  void clear_has_skip_setsid();
  void set_has_stderr_to_null();
  void clear_has_stderr_to_null();
  void set_has_disable_no_new_privs();
  void clear_has_disable_no_new_privs();
  void set_has_rlimit_as();
  void clear_has_rlimit_as();
  void set_has_rlimit_as_type();
  void clear_has_rlimit_as_type();
  void set_has_rlimit_core();
  void clear_has_rlimit_core();
  void set_has_rlimit_core_type();
  void clear_has_rlimit_core_type();
  void set_has_rlimit_cpu();
  void clear_has_rlimit_cpu();
  void set_has_rlimit_cpu_type();
  void clear_has_rlimit_cpu_type();
  void set_has_rlimit_fsize();
  void clear_has_rlimit_fsize();
  void set_has_rlimit_fsize_type();
  void clear_has_rlimit_fsize_type();
  void set_has_rlimit_nofile();
  void clear_has_rlimit_nofile();
  void set_has_rlimit_nofile_type();
  void clear_has_rlimit_nofile_type();
  void set_has_rlimit_nproc();
  void clear_has_rlimit_nproc();
  void set_has_rlimit_nproc_type();
  void clear_has_rlimit_nproc_type();
  void set_has_rlimit_stack();
  void clear_has_rlimit_stack();
  void set_has_rlimit_stack_type();
  void clear_has_rlimit_stack_type();
  void set_has_rlimit_memlock();
  void clear_has_rlimit_memlock();
  void set_has_rlimit_memlock_type();
  void clear_has_rlimit_memlock_type();
  void set_has_rlimit_rtprio();
  void clear_has_rlimit_rtprio();
  void set_has_rlimit_rtprio_type();
  void clear_has_rlimit_rtprio_type();
  void set_has_rlimit_msgqueue();
  void clear_has_rlimit_msgqueue();
  void set_has_rlimit_msgqueue_type();
  void clear_has_rlimit_msgqueue_type();
  void set_has_disable_rl();
  void clear_has_disable_rl();
  void set_has_persona_addr_compat_layout();
  void clear_has_persona_addr_compat_layout();
  void set_has_persona_mmap_page_zero();
  void clear_has_persona_mmap_page_zero();
  void set_has_persona_read_implies_exec();
  void clear_has_persona_read_implies_exec();
  void set_has_persona_addr_limit_3gb();
  void clear_has_persona_addr_limit_3gb();
  void set_has_persona_addr_no_randomize();
  void clear_has_persona_addr_no_randomize();
  void set_has_clone_newnet();
  void clear_has_clone_newnet();
  void set_has_clone_newuser();
  void clear_has_clone_newuser();
  void set_has_clone_newns();
  void clear_has_clone_newns();
  void set_has_clone_newpid();
  void clear_has_clone_newpid();
  void set_has_clone_newipc();
  void clear_has_clone_newipc();
  void set_has_clone_newuts();
  void clear_has_clone_newuts();
  void set_has_clone_newcgroup();
  void clear_has_clone_newcgroup();
  void set_has_clone_newtime();
  void clear_has_clone_newtime();
  void set_has_mount_proc();
  void clear_has_mount_proc();
  void set_has_seccomp_policy_file();
  void clear_has_seccomp_policy_file();
  void set_has_seccomp_log();
  void clear_has_seccomp_log();
  void set_has_cgroup_mem_max();
  void clear_has_cgroup_mem_max();
  void set_has_cgroup_mem_memsw_max();
  void clear_has_cgroup_mem_memsw_max();
  void set_has_cgroup_mem_swap_max();
  void clear_has_cgroup_mem_swap_max();
  void set_has_cgroup_mem_mount();
  void clear_has_cgroup_mem_mount();
  void set_has_cgroup_mem_parent();
  void clear_has_cgroup_mem_parent();
  void set_has_cgroup_pids_max();
  void clear_has_cgroup_pids_max();
  void set_has_cgroup_pids_mount();
  void clear_has_cgroup_pids_mount();
  void set_has_cgroup_pids_parent();
  void clear_has_cgroup_pids_parent();
  void set_has_cgroup_net_cls_classid();
  void clear_has_cgroup_net_cls_classid();
  void set_has_cgroup_net_cls_mount();
  void clear_has_cgroup_net_cls_mount();
  void set_has_cgroup_net_cls_parent();
  void clear_has_cgroup_net_cls_parent();
  void set_has_cgroup_cpu_ms_per_sec();
  void clear_has_cgroup_cpu_ms_per_sec();
  void set_has_cgroup_cpu_mount();
  void clear_has_cgroup_cpu_mount();
  void set_has_cgroup_cpu_parent();
  void clear_has_cgroup_cpu_parent();
  void set_has_cgroupv2_mount();
  void clear_has_cgroupv2_mount();
  void set_has_use_cgroupv2();
  void clear_has_use_cgroupv2();
  void set_has_iface_no_lo();
  void clear_has_iface_no_lo();
  void set_has_macvlan_iface();
  void clear_has_macvlan_iface();
  void set_has_macvlan_vs_ip();
  void clear_has_macvlan_vs_ip();
  void set_has_macvlan_vs_nm();
  void clear_has_macvlan_vs_nm();
  void set_has_macvlan_vs_gw();
  void clear_has_macvlan_vs_gw();
  void set_has_macvlan_vs_ma();
  void clear_has_macvlan_vs_ma();
  void set_has_macvlan_vs_mo();
  void clear_has_macvlan_vs_mo();
  void set_has_nice_level();
  void clear_has_nice_level();
  void set_has_exec_bin();
  void clear_has_exec_bin();
  void set_has_disable_tsc();
  void clear_has_disable_tsc();
  void set_has_forward_signals();
  void clear_has_forward_signals();
  void set_has_detect_cgroupv2();
  void clear_has_detect_cgroupv2();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<3> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> description_;
  ::google::protobuf::RepeatedPtrField< ::std::string> envar_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cap_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pass_fd_;
  ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap > uidmap_;
  ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap > gidmap_;
  ::google::protobuf::RepeatedPtrField< ::nsjail::MountPt > mount_;
  ::google::protobuf::RepeatedPtrField< ::std::string> seccomp_string_;
  ::google::protobuf::RepeatedPtrField< ::std::string> iface_own_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_hostname_;
  private:
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cwd_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cwd_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_bindhost_;
  private:
  ::google::protobuf::internal::ArenaStringPtr bindhost_;
  ::google::protobuf::internal::ArenaStringPtr log_file_;
  ::google::protobuf::internal::ArenaStringPtr seccomp_policy_file_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroup_mem_mount_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroup_mem_mount_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroup_mem_parent_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroup_mem_parent_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroup_pids_mount_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroup_pids_mount_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroup_pids_parent_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroup_pids_parent_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroup_net_cls_mount_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroup_net_cls_parent_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroup_cpu_mount_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroup_cpu_mount_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroup_cpu_parent_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroup_cpu_parent_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_cgroupv2_mount_;
  private:
  ::google::protobuf::internal::ArenaStringPtr cgroupv2_mount_;
  ::google::protobuf::internal::ArenaStringPtr macvlan_iface_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_macvlan_vs_ip_;
  private:
  ::google::protobuf::internal::ArenaStringPtr macvlan_vs_ip_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_macvlan_vs_nm_;
  private:
  ::google::protobuf::internal::ArenaStringPtr macvlan_vs_nm_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_macvlan_vs_gw_;
  private:
  ::google::protobuf::internal::ArenaStringPtr macvlan_vs_gw_;
  ::google::protobuf::internal::ArenaStringPtr macvlan_vs_ma_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_macvlan_vs_mo_;
  private:
  ::google::protobuf::internal::ArenaStringPtr macvlan_vs_mo_;
  ::nsjail::Exe* exec_bin_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 max_conns_;
  ::google::protobuf::uint32 max_conns_per_ip_;
  ::google::protobuf::uint32 max_cpus_;
  bool no_pivotroot_;
  bool daemon_;
  bool keep_env_;
  bool keep_caps_;
  ::google::protobuf::int32 log_fd_;
  int log_level_;
  bool silent_;
  bool skip_setsid_;
  bool stderr_to_null_;
  bool disable_no_new_privs_;
  ::google::protobuf::uint64 rlimit_core_;
  int rlimit_as_type_;
  int rlimit_core_type_;
  int rlimit_cpu_type_;
  int rlimit_fsize_type_;
  ::google::protobuf::uint64 rlimit_rtprio_;
  int rlimit_nofile_type_;
  bool disable_rl_;
  bool persona_addr_compat_layout_;
  bool persona_mmap_page_zero_;
  bool persona_read_implies_exec_;
  bool persona_addr_limit_3gb_;
  bool persona_addr_no_randomize_;
  bool clone_newtime_;
  bool mount_proc_;
  ::google::protobuf::uint32 cgroup_net_cls_classid_;
  ::google::protobuf::uint64 cgroup_mem_max_;
  ::google::protobuf::uint64 cgroup_pids_max_;
  ::google::protobuf::uint32 cgroup_cpu_ms_per_sec_;
  bool seccomp_log_;
  bool use_cgroupv2_;
  bool iface_no_lo_;
  bool disable_tsc_;
  ::google::protobuf::uint64 cgroup_mem_memsw_max_;
  bool forward_signals_;
  bool detect_cgroupv2_;
  int mode_;
  ::google::protobuf::uint32 time_limit_;
  ::google::protobuf::uint64 rlimit_as_;
  ::google::protobuf::uint64 rlimit_cpu_;
  ::google::protobuf::uint64 rlimit_fsize_;
  ::google::protobuf::uint64 rlimit_nofile_;
  ::google::protobuf::uint64 rlimit_nproc_;
  ::google::protobuf::uint64 rlimit_stack_;
  int rlimit_nproc_type_;
  int rlimit_stack_type_;
  ::google::protobuf::uint64 rlimit_memlock_;
  int rlimit_memlock_type_;
  int rlimit_rtprio_type_;
  ::google::protobuf::uint64 rlimit_msgqueue_;
  int rlimit_msgqueue_type_;
  bool clone_newnet_;
  bool clone_newuser_;
  bool clone_newns_;
  bool clone_newpid_;
  bool clone_newipc_;
  bool clone_newuts_;
  bool clone_newcgroup_;
  ::google::protobuf::int32 nice_level_;
  ::google::protobuf::int64 cgroup_mem_swap_max_;
  friend struct ::protobuf_config_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IdMap

// optional string inside_id = 1 [default = ""];
inline bool IdMap::has_inside_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdMap::set_has_inside_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IdMap::clear_has_inside_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IdMap::clear_inside_id() {
  inside_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_inside_id();
}
inline const ::std::string& IdMap::inside_id() const {
  // @@protoc_insertion_point(field_get:nsjail.IdMap.inside_id)
  return inside_id_.GetNoArena();
}
inline void IdMap::set_inside_id(const ::std::string& value) {
  set_has_inside_id();
  inside_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.IdMap.inside_id)
}
#if LANG_CXX11
inline void IdMap::set_inside_id(::std::string&& value) {
  set_has_inside_id();
  inside_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.IdMap.inside_id)
}
#endif
inline void IdMap::set_inside_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_inside_id();
  inside_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.IdMap.inside_id)
}
inline void IdMap::set_inside_id(const char* value, size_t size) {
  set_has_inside_id();
  inside_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.IdMap.inside_id)
}
inline ::std::string* IdMap::mutable_inside_id() {
  set_has_inside_id();
  // @@protoc_insertion_point(field_mutable:nsjail.IdMap.inside_id)
  return inside_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdMap::release_inside_id() {
  // @@protoc_insertion_point(field_release:nsjail.IdMap.inside_id)
  if (!has_inside_id()) {
    return NULL;
  }
  clear_has_inside_id();
  return inside_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdMap::set_allocated_inside_id(::std::string* inside_id) {
  if (inside_id != NULL) {
    set_has_inside_id();
  } else {
    clear_has_inside_id();
  }
  inside_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), inside_id);
  // @@protoc_insertion_point(field_set_allocated:nsjail.IdMap.inside_id)
}

// optional string outside_id = 2 [default = ""];
inline bool IdMap::has_outside_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdMap::set_has_outside_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IdMap::clear_has_outside_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IdMap::clear_outside_id() {
  outside_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_outside_id();
}
inline const ::std::string& IdMap::outside_id() const {
  // @@protoc_insertion_point(field_get:nsjail.IdMap.outside_id)
  return outside_id_.GetNoArena();
}
inline void IdMap::set_outside_id(const ::std::string& value) {
  set_has_outside_id();
  outside_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.IdMap.outside_id)
}
#if LANG_CXX11
inline void IdMap::set_outside_id(::std::string&& value) {
  set_has_outside_id();
  outside_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.IdMap.outside_id)
}
#endif
inline void IdMap::set_outside_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_outside_id();
  outside_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.IdMap.outside_id)
}
inline void IdMap::set_outside_id(const char* value, size_t size) {
  set_has_outside_id();
  outside_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.IdMap.outside_id)
}
inline ::std::string* IdMap::mutable_outside_id() {
  set_has_outside_id();
  // @@protoc_insertion_point(field_mutable:nsjail.IdMap.outside_id)
  return outside_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdMap::release_outside_id() {
  // @@protoc_insertion_point(field_release:nsjail.IdMap.outside_id)
  if (!has_outside_id()) {
    return NULL;
  }
  clear_has_outside_id();
  return outside_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdMap::set_allocated_outside_id(::std::string* outside_id) {
  if (outside_id != NULL) {
    set_has_outside_id();
  } else {
    clear_has_outside_id();
  }
  outside_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), outside_id);
  // @@protoc_insertion_point(field_set_allocated:nsjail.IdMap.outside_id)
}

// optional uint32 count = 3 [default = 1];
inline bool IdMap::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IdMap::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IdMap::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IdMap::clear_count() {
  count_ = 1u;
  clear_has_count();
}
inline ::google::protobuf::uint32 IdMap::count() const {
  // @@protoc_insertion_point(field_get:nsjail.IdMap.count)
  return count_;
}
inline void IdMap::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:nsjail.IdMap.count)
}

// optional bool use_newidmap = 4 [default = false];
inline bool IdMap::has_use_newidmap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IdMap::set_has_use_newidmap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IdMap::clear_has_use_newidmap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IdMap::clear_use_newidmap() {
  use_newidmap_ = false;
  clear_has_use_newidmap();
}
inline bool IdMap::use_newidmap() const {
  // @@protoc_insertion_point(field_get:nsjail.IdMap.use_newidmap)
  return use_newidmap_;
}
inline void IdMap::set_use_newidmap(bool value) {
  set_has_use_newidmap();
  use_newidmap_ = value;
  // @@protoc_insertion_point(field_set:nsjail.IdMap.use_newidmap)
}

// -------------------------------------------------------------------

// MountPt

// optional string src = 1 [default = ""];
inline bool MountPt::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MountPt::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MountPt::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MountPt::clear_src() {
  src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src();
}
inline const ::std::string& MountPt::src() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.src)
  return src_.GetNoArena();
}
inline void MountPt::set_src(const ::std::string& value) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.src)
}
#if LANG_CXX11
inline void MountPt::set_src(::std::string&& value) {
  set_has_src();
  src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.src)
}
#endif
inline void MountPt::set_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.src)
}
inline void MountPt::set_src(const char* value, size_t size) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.src)
}
inline ::std::string* MountPt::mutable_src() {
  set_has_src();
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.src)
  return src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MountPt::release_src() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.src)
  if (!has_src()) {
    return NULL;
  }
  clear_has_src();
  return src_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MountPt::set_allocated_src(::std::string* src) {
  if (src != NULL) {
    set_has_src();
  } else {
    clear_has_src();
  }
  src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.src)
}

// optional string prefix_src_env = 2 [default = ""];
inline bool MountPt::has_prefix_src_env() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MountPt::set_has_prefix_src_env() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MountPt::clear_has_prefix_src_env() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MountPt::clear_prefix_src_env() {
  prefix_src_env_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prefix_src_env();
}
inline const ::std::string& MountPt::prefix_src_env() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.prefix_src_env)
  return prefix_src_env_.GetNoArena();
}
inline void MountPt::set_prefix_src_env(const ::std::string& value) {
  set_has_prefix_src_env();
  prefix_src_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.prefix_src_env)
}
#if LANG_CXX11
inline void MountPt::set_prefix_src_env(::std::string&& value) {
  set_has_prefix_src_env();
  prefix_src_env_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.prefix_src_env)
}
#endif
inline void MountPt::set_prefix_src_env(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prefix_src_env();
  prefix_src_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.prefix_src_env)
}
inline void MountPt::set_prefix_src_env(const char* value, size_t size) {
  set_has_prefix_src_env();
  prefix_src_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.prefix_src_env)
}
inline ::std::string* MountPt::mutable_prefix_src_env() {
  set_has_prefix_src_env();
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.prefix_src_env)
  return prefix_src_env_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MountPt::release_prefix_src_env() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.prefix_src_env)
  if (!has_prefix_src_env()) {
    return NULL;
  }
  clear_has_prefix_src_env();
  return prefix_src_env_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MountPt::set_allocated_prefix_src_env(::std::string* prefix_src_env) {
  if (prefix_src_env != NULL) {
    set_has_prefix_src_env();
  } else {
    clear_has_prefix_src_env();
  }
  prefix_src_env_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix_src_env);
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.prefix_src_env)
}

// optional bytes src_content = 3 [default = ""];
inline bool MountPt::has_src_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MountPt::set_has_src_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MountPt::clear_has_src_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MountPt::clear_src_content() {
  src_content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_content();
}
inline const ::std::string& MountPt::src_content() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.src_content)
  return src_content_.GetNoArena();
}
inline void MountPt::set_src_content(const ::std::string& value) {
  set_has_src_content();
  src_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.src_content)
}
#if LANG_CXX11
inline void MountPt::set_src_content(::std::string&& value) {
  set_has_src_content();
  src_content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.src_content)
}
#endif
inline void MountPt::set_src_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_content();
  src_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.src_content)
}
inline void MountPt::set_src_content(const void* value, size_t size) {
  set_has_src_content();
  src_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.src_content)
}
inline ::std::string* MountPt::mutable_src_content() {
  set_has_src_content();
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.src_content)
  return src_content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MountPt::release_src_content() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.src_content)
  if (!has_src_content()) {
    return NULL;
  }
  clear_has_src_content();
  return src_content_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MountPt::set_allocated_src_content(::std::string* src_content) {
  if (src_content != NULL) {
    set_has_src_content();
  } else {
    clear_has_src_content();
  }
  src_content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_content);
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.src_content)
}

// required string dst = 4 [default = ""];
inline bool MountPt::has_dst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MountPt::set_has_dst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MountPt::clear_has_dst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MountPt::clear_dst() {
  dst_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dst();
}
inline const ::std::string& MountPt::dst() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.dst)
  return dst_.GetNoArena();
}
inline void MountPt::set_dst(const ::std::string& value) {
  set_has_dst();
  dst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.dst)
}
#if LANG_CXX11
inline void MountPt::set_dst(::std::string&& value) {
  set_has_dst();
  dst_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.dst)
}
#endif
inline void MountPt::set_dst(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dst();
  dst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.dst)
}
inline void MountPt::set_dst(const char* value, size_t size) {
  set_has_dst();
  dst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.dst)
}
inline ::std::string* MountPt::mutable_dst() {
  set_has_dst();
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.dst)
  return dst_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MountPt::release_dst() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.dst)
  if (!has_dst()) {
    return NULL;
  }
  clear_has_dst();
  return dst_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MountPt::set_allocated_dst(::std::string* dst) {
  if (dst != NULL) {
    set_has_dst();
  } else {
    clear_has_dst();
  }
  dst_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dst);
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.dst)
}

// optional string prefix_dst_env = 5 [default = ""];
inline bool MountPt::has_prefix_dst_env() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MountPt::set_has_prefix_dst_env() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MountPt::clear_has_prefix_dst_env() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MountPt::clear_prefix_dst_env() {
  prefix_dst_env_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prefix_dst_env();
}
inline const ::std::string& MountPt::prefix_dst_env() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.prefix_dst_env)
  return prefix_dst_env_.GetNoArena();
}
inline void MountPt::set_prefix_dst_env(const ::std::string& value) {
  set_has_prefix_dst_env();
  prefix_dst_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.prefix_dst_env)
}
#if LANG_CXX11
inline void MountPt::set_prefix_dst_env(::std::string&& value) {
  set_has_prefix_dst_env();
  prefix_dst_env_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.prefix_dst_env)
}
#endif
inline void MountPt::set_prefix_dst_env(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prefix_dst_env();
  prefix_dst_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.prefix_dst_env)
}
inline void MountPt::set_prefix_dst_env(const char* value, size_t size) {
  set_has_prefix_dst_env();
  prefix_dst_env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.prefix_dst_env)
}
inline ::std::string* MountPt::mutable_prefix_dst_env() {
  set_has_prefix_dst_env();
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.prefix_dst_env)
  return prefix_dst_env_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MountPt::release_prefix_dst_env() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.prefix_dst_env)
  if (!has_prefix_dst_env()) {
    return NULL;
  }
  clear_has_prefix_dst_env();
  return prefix_dst_env_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MountPt::set_allocated_prefix_dst_env(::std::string* prefix_dst_env) {
  if (prefix_dst_env != NULL) {
    set_has_prefix_dst_env();
  } else {
    clear_has_prefix_dst_env();
  }
  prefix_dst_env_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix_dst_env);
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.prefix_dst_env)
}

// optional string fstype = 6 [default = ""];
inline bool MountPt::has_fstype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MountPt::set_has_fstype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MountPt::clear_has_fstype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MountPt::clear_fstype() {
  fstype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fstype();
}
inline const ::std::string& MountPt::fstype() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.fstype)
  return fstype_.GetNoArena();
}
inline void MountPt::set_fstype(const ::std::string& value) {
  set_has_fstype();
  fstype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.fstype)
}
#if LANG_CXX11
inline void MountPt::set_fstype(::std::string&& value) {
  set_has_fstype();
  fstype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.fstype)
}
#endif
inline void MountPt::set_fstype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fstype();
  fstype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.fstype)
}
inline void MountPt::set_fstype(const char* value, size_t size) {
  set_has_fstype();
  fstype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.fstype)
}
inline ::std::string* MountPt::mutable_fstype() {
  set_has_fstype();
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.fstype)
  return fstype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MountPt::release_fstype() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.fstype)
  if (!has_fstype()) {
    return NULL;
  }
  clear_has_fstype();
  return fstype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MountPt::set_allocated_fstype(::std::string* fstype) {
  if (fstype != NULL) {
    set_has_fstype();
  } else {
    clear_has_fstype();
  }
  fstype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fstype);
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.fstype)
}

// optional string options = 7 [default = ""];
inline bool MountPt::has_options() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MountPt::set_has_options() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MountPt::clear_has_options() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MountPt::clear_options() {
  options_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_options();
}
inline const ::std::string& MountPt::options() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.options)
  return options_.GetNoArena();
}
inline void MountPt::set_options(const ::std::string& value) {
  set_has_options();
  options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.options)
}
#if LANG_CXX11
inline void MountPt::set_options(::std::string&& value) {
  set_has_options();
  options_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.options)
}
#endif
inline void MountPt::set_options(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_options();
  options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.options)
}
inline void MountPt::set_options(const char* value, size_t size) {
  set_has_options();
  options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.options)
}
inline ::std::string* MountPt::mutable_options() {
  set_has_options();
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.options)
  return options_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MountPt::release_options() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.options)
  if (!has_options()) {
    return NULL;
  }
  clear_has_options();
  return options_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MountPt::set_allocated_options(::std::string* options) {
  if (options != NULL) {
    set_has_options();
  } else {
    clear_has_options();
  }
  options_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), options);
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.options)
}

// optional bool is_bind = 8 [default = false];
inline bool MountPt::has_is_bind() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MountPt::set_has_is_bind() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MountPt::clear_has_is_bind() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MountPt::clear_is_bind() {
  is_bind_ = false;
  clear_has_is_bind();
}
inline bool MountPt::is_bind() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.is_bind)
  return is_bind_;
}
inline void MountPt::set_is_bind(bool value) {
  set_has_is_bind();
  is_bind_ = value;
  // @@protoc_insertion_point(field_set:nsjail.MountPt.is_bind)
}

// optional bool rw = 9 [default = false];
inline bool MountPt::has_rw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MountPt::set_has_rw() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MountPt::clear_has_rw() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MountPt::clear_rw() {
  rw_ = false;
  clear_has_rw();
}
inline bool MountPt::rw() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.rw)
  return rw_;
}
inline void MountPt::set_rw(bool value) {
  set_has_rw();
  rw_ = value;
  // @@protoc_insertion_point(field_set:nsjail.MountPt.rw)
}

// optional bool is_dir = 10;
inline bool MountPt::has_is_dir() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MountPt::set_has_is_dir() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MountPt::clear_has_is_dir() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MountPt::clear_is_dir() {
  is_dir_ = false;
  clear_has_is_dir();
}
inline bool MountPt::is_dir() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.is_dir)
  return is_dir_;
}
inline void MountPt::set_is_dir(bool value) {
  set_has_is_dir();
  is_dir_ = value;
  // @@protoc_insertion_point(field_set:nsjail.MountPt.is_dir)
}

// optional bool mandatory = 11 [default = true];
inline bool MountPt::has_mandatory() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MountPt::set_has_mandatory() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MountPt::clear_has_mandatory() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MountPt::clear_mandatory() {
  mandatory_ = true;
  clear_has_mandatory();
}
inline bool MountPt::mandatory() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.mandatory)
  return mandatory_;
}
inline void MountPt::set_mandatory(bool value) {
  set_has_mandatory();
  mandatory_ = value;
  // @@protoc_insertion_point(field_set:nsjail.MountPt.mandatory)
}

// optional bool is_symlink = 12 [default = false];
inline bool MountPt::has_is_symlink() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MountPt::set_has_is_symlink() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MountPt::clear_has_is_symlink() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MountPt::clear_is_symlink() {
  is_symlink_ = false;
  clear_has_is_symlink();
}
inline bool MountPt::is_symlink() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.is_symlink)
  return is_symlink_;
}
inline void MountPt::set_is_symlink(bool value) {
  set_has_is_symlink();
  is_symlink_ = value;
  // @@protoc_insertion_point(field_set:nsjail.MountPt.is_symlink)
}

// optional bool nosuid = 13 [default = false];
inline bool MountPt::has_nosuid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MountPt::set_has_nosuid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MountPt::clear_has_nosuid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MountPt::clear_nosuid() {
  nosuid_ = false;
  clear_has_nosuid();
}
inline bool MountPt::nosuid() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.nosuid)
  return nosuid_;
}
inline void MountPt::set_nosuid(bool value) {
  set_has_nosuid();
  nosuid_ = value;
  // @@protoc_insertion_point(field_set:nsjail.MountPt.nosuid)
}

// optional bool nodev = 14 [default = false];
inline bool MountPt::has_nodev() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MountPt::set_has_nodev() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MountPt::clear_has_nodev() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MountPt::clear_nodev() {
  nodev_ = false;
  clear_has_nodev();
}
inline bool MountPt::nodev() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.nodev)
  return nodev_;
}
inline void MountPt::set_nodev(bool value) {
  set_has_nodev();
  nodev_ = value;
  // @@protoc_insertion_point(field_set:nsjail.MountPt.nodev)
}

// optional bool noexec = 15 [default = false];
inline bool MountPt::has_noexec() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MountPt::set_has_noexec() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MountPt::clear_has_noexec() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MountPt::clear_noexec() {
  noexec_ = false;
  clear_has_noexec();
}
inline bool MountPt::noexec() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.noexec)
  return noexec_;
}
inline void MountPt::set_noexec(bool value) {
  set_has_noexec();
  noexec_ = value;
  // @@protoc_insertion_point(field_set:nsjail.MountPt.noexec)
}

// -------------------------------------------------------------------

// Exe

// required string path = 1;
inline bool Exe::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exe::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exe::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exe::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& Exe::path() const {
  // @@protoc_insertion_point(field_get:nsjail.Exe.path)
  return path_.GetNoArena();
}
inline void Exe::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.Exe.path)
}
#if LANG_CXX11
inline void Exe::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.Exe.path)
}
#endif
inline void Exe::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.Exe.path)
}
inline void Exe::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.Exe.path)
}
inline ::std::string* Exe::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:nsjail.Exe.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Exe::release_path() {
  // @@protoc_insertion_point(field_release:nsjail.Exe.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Exe::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:nsjail.Exe.path)
}

// repeated string arg = 2;
inline int Exe::arg_size() const {
  return arg_.size();
}
inline void Exe::clear_arg() {
  arg_.Clear();
}
inline const ::std::string& Exe::arg(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.Exe.arg)
  return arg_.Get(index);
}
inline ::std::string* Exe::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.Exe.arg)
  return arg_.Mutable(index);
}
inline void Exe::set_arg(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.Exe.arg)
  arg_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Exe::set_arg(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.Exe.arg)
  arg_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Exe::set_arg(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.Exe.arg)
}
inline void Exe::set_arg(int index, const char* value, size_t size) {
  arg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.Exe.arg)
}
inline ::std::string* Exe::add_arg() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.Exe.arg)
  return arg_.Add();
}
inline void Exe::add_arg(const ::std::string& value) {
  arg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.Exe.arg)
}
#if LANG_CXX11
inline void Exe::add_arg(::std::string&& value) {
  arg_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.Exe.arg)
}
#endif
inline void Exe::add_arg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.Exe.arg)
}
inline void Exe::add_arg(const char* value, size_t size) {
  arg_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.Exe.arg)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Exe::arg() const {
  // @@protoc_insertion_point(field_list:nsjail.Exe.arg)
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Exe::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.Exe.arg)
  return &arg_;
}

// optional string arg0 = 3;
inline bool Exe::has_arg0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exe::set_has_arg0() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exe::clear_has_arg0() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exe::clear_arg0() {
  arg0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_arg0();
}
inline const ::std::string& Exe::arg0() const {
  // @@protoc_insertion_point(field_get:nsjail.Exe.arg0)
  return arg0_.GetNoArena();
}
inline void Exe::set_arg0(const ::std::string& value) {
  set_has_arg0();
  arg0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.Exe.arg0)
}
#if LANG_CXX11
inline void Exe::set_arg0(::std::string&& value) {
  set_has_arg0();
  arg0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.Exe.arg0)
}
#endif
inline void Exe::set_arg0(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_arg0();
  arg0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.Exe.arg0)
}
inline void Exe::set_arg0(const char* value, size_t size) {
  set_has_arg0();
  arg0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.Exe.arg0)
}
inline ::std::string* Exe::mutable_arg0() {
  set_has_arg0();
  // @@protoc_insertion_point(field_mutable:nsjail.Exe.arg0)
  return arg0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Exe::release_arg0() {
  // @@protoc_insertion_point(field_release:nsjail.Exe.arg0)
  if (!has_arg0()) {
    return NULL;
  }
  clear_has_arg0();
  return arg0_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Exe::set_allocated_arg0(::std::string* arg0) {
  if (arg0 != NULL) {
    set_has_arg0();
  } else {
    clear_has_arg0();
  }
  arg0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), arg0);
  // @@protoc_insertion_point(field_set_allocated:nsjail.Exe.arg0)
}

// optional bool exec_fd = 4 [default = false];
inline bool Exe::has_exec_fd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Exe::set_has_exec_fd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Exe::clear_has_exec_fd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Exe::clear_exec_fd() {
  exec_fd_ = false;
  clear_has_exec_fd();
}
inline bool Exe::exec_fd() const {
  // @@protoc_insertion_point(field_get:nsjail.Exe.exec_fd)
  return exec_fd_;
}
inline void Exe::set_exec_fd(bool value) {
  set_has_exec_fd();
  exec_fd_ = value;
  // @@protoc_insertion_point(field_set:nsjail.Exe.exec_fd)
}

// -------------------------------------------------------------------

// NsJailConfig

// optional string name = 1 [default = ""];
inline bool NsJailConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NsJailConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NsJailConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NsJailConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& NsJailConfig::name() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.name)
  return name_.GetNoArena();
}
inline void NsJailConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.name)
}
#if LANG_CXX11
inline void NsJailConfig::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.name)
}
#endif
inline void NsJailConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.name)
}
inline void NsJailConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.name)
}
inline ::std::string* NsJailConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NsJailConfig::release_name() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NsJailConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.name)
}

// repeated string description = 2;
inline int NsJailConfig::description_size() const {
  return description_.size();
}
inline void NsJailConfig::clear_description() {
  description_.Clear();
}
inline const ::std::string& NsJailConfig::description(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.description)
  return description_.Get(index);
}
inline ::std::string* NsJailConfig::mutable_description(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.description)
  return description_.Mutable(index);
}
inline void NsJailConfig::set_description(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.description)
  description_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NsJailConfig::set_description(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.description)
  description_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NsJailConfig::set_description(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  description_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.description)
}
inline void NsJailConfig::set_description(int index, const char* value, size_t size) {
  description_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.description)
}
inline ::std::string* NsJailConfig::add_description() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.description)
  return description_.Add();
}
inline void NsJailConfig::add_description(const ::std::string& value) {
  description_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.description)
}
#if LANG_CXX11
inline void NsJailConfig::add_description(::std::string&& value) {
  description_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.description)
}
#endif
inline void NsJailConfig::add_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  description_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.description)
}
inline void NsJailConfig::add_description(const char* value, size_t size) {
  description_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.description)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NsJailConfig::description() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.description)
  return description_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NsJailConfig::mutable_description() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.description)
  return &description_;
}

// optional .nsjail.Mode mode = 3 [default = ONCE];
inline bool NsJailConfig::has_mode() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void NsJailConfig::set_has_mode() {
  _has_bits_[1] |= 0x40000000u;
}
inline void NsJailConfig::clear_has_mode() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void NsJailConfig::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::nsjail::Mode NsJailConfig::mode() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.mode)
  return static_cast< ::nsjail::Mode >(mode_);
}
inline void NsJailConfig::set_mode(::nsjail::Mode value) {
  assert(::nsjail::Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.mode)
}

// optional string hostname = 4 [default = "NSJAIL"];
inline bool NsJailConfig::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NsJailConfig::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NsJailConfig::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NsJailConfig::clear_hostname() {
  hostname_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_.get());
  clear_has_hostname();
}
inline const ::std::string& NsJailConfig::hostname() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.hostname)
  return hostname_.GetNoArena();
}
inline void NsJailConfig::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.hostname)
}
#if LANG_CXX11
inline void NsJailConfig::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.hostname)
}
#endif
inline void NsJailConfig::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.hostname)
}
inline void NsJailConfig::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.hostname)
}
inline ::std::string* NsJailConfig::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.hostname)
  return hostname_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_.get());
}
inline ::std::string* NsJailConfig::release_hostname() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.hostname)
  if (!has_hostname()) {
    return NULL;
  }
  clear_has_hostname();
  return hostname_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_.get());
}
inline void NsJailConfig::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_.get(), hostname);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.hostname)
}

// optional string cwd = 5 [default = "/"];
inline bool NsJailConfig::has_cwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NsJailConfig::set_has_cwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NsJailConfig::clear_has_cwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NsJailConfig::clear_cwd() {
  cwd_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_.get());
  clear_has_cwd();
}
inline const ::std::string& NsJailConfig::cwd() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cwd)
  return cwd_.GetNoArena();
}
inline void NsJailConfig::set_cwd(const ::std::string& value) {
  set_has_cwd();
  cwd_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cwd)
}
#if LANG_CXX11
inline void NsJailConfig::set_cwd(::std::string&& value) {
  set_has_cwd();
  cwd_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cwd)
}
#endif
inline void NsJailConfig::set_cwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cwd();
  cwd_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cwd)
}
inline void NsJailConfig::set_cwd(const char* value, size_t size) {
  set_has_cwd();
  cwd_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cwd)
}
inline ::std::string* NsJailConfig::mutable_cwd() {
  set_has_cwd();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cwd)
  return cwd_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_.get());
}
inline ::std::string* NsJailConfig::release_cwd() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cwd)
  if (!has_cwd()) {
    return NULL;
  }
  clear_has_cwd();
  return cwd_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_.get());
}
inline void NsJailConfig::set_allocated_cwd(::std::string* cwd) {
  if (cwd != NULL) {
    set_has_cwd();
  } else {
    clear_has_cwd();
  }
  cwd_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_.get(), cwd);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cwd)
}

// optional bool no_pivotroot = 6 [default = false];
inline bool NsJailConfig::has_no_pivotroot() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void NsJailConfig::set_has_no_pivotroot() {
  _has_bits_[0] |= 0x04000000u;
}
inline void NsJailConfig::clear_has_no_pivotroot() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void NsJailConfig::clear_no_pivotroot() {
  no_pivotroot_ = false;
  clear_has_no_pivotroot();
}
inline bool NsJailConfig::no_pivotroot() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.no_pivotroot)
  return no_pivotroot_;
}
inline void NsJailConfig::set_no_pivotroot(bool value) {
  set_has_no_pivotroot();
  no_pivotroot_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.no_pivotroot)
}

// optional uint32 port = 7 [default = 0];
inline bool NsJailConfig::has_port() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NsJailConfig::set_has_port() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NsJailConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NsJailConfig::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 NsJailConfig::port() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.port)
  return port_;
}
inline void NsJailConfig::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.port)
}

// optional string bindhost = 8 [default = "::"];
inline bool NsJailConfig::has_bindhost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NsJailConfig::set_has_bindhost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NsJailConfig::clear_has_bindhost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NsJailConfig::clear_bindhost() {
  bindhost_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_.get());
  clear_has_bindhost();
}
inline const ::std::string& NsJailConfig::bindhost() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.bindhost)
  return bindhost_.GetNoArena();
}
inline void NsJailConfig::set_bindhost(const ::std::string& value) {
  set_has_bindhost();
  bindhost_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.bindhost)
}
#if LANG_CXX11
inline void NsJailConfig::set_bindhost(::std::string&& value) {
  set_has_bindhost();
  bindhost_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.bindhost)
}
#endif
inline void NsJailConfig::set_bindhost(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bindhost();
  bindhost_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.bindhost)
}
inline void NsJailConfig::set_bindhost(const char* value, size_t size) {
  set_has_bindhost();
  bindhost_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.bindhost)
}
inline ::std::string* NsJailConfig::mutable_bindhost() {
  set_has_bindhost();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.bindhost)
  return bindhost_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_.get());
}
inline ::std::string* NsJailConfig::release_bindhost() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.bindhost)
  if (!has_bindhost()) {
    return NULL;
  }
  clear_has_bindhost();
  return bindhost_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_.get());
}
inline void NsJailConfig::set_allocated_bindhost(::std::string* bindhost) {
  if (bindhost != NULL) {
    set_has_bindhost();
  } else {
    clear_has_bindhost();
  }
  bindhost_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_.get(), bindhost);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.bindhost)
}

// optional uint32 max_conns = 9 [default = 0];
inline bool NsJailConfig::has_max_conns() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NsJailConfig::set_has_max_conns() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NsJailConfig::clear_has_max_conns() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NsJailConfig::clear_max_conns() {
  max_conns_ = 0u;
  clear_has_max_conns();
}
inline ::google::protobuf::uint32 NsJailConfig::max_conns() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.max_conns)
  return max_conns_;
}
inline void NsJailConfig::set_max_conns(::google::protobuf::uint32 value) {
  set_has_max_conns();
  max_conns_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.max_conns)
}

// optional uint32 max_conns_per_ip = 10 [default = 0];
inline bool NsJailConfig::has_max_conns_per_ip() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NsJailConfig::set_has_max_conns_per_ip() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NsJailConfig::clear_has_max_conns_per_ip() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NsJailConfig::clear_max_conns_per_ip() {
  max_conns_per_ip_ = 0u;
  clear_has_max_conns_per_ip();
}
inline ::google::protobuf::uint32 NsJailConfig::max_conns_per_ip() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.max_conns_per_ip)
  return max_conns_per_ip_;
}
inline void NsJailConfig::set_max_conns_per_ip(::google::protobuf::uint32 value) {
  set_has_max_conns_per_ip();
  max_conns_per_ip_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.max_conns_per_ip)
}

// optional uint32 time_limit = 11 [default = 600];
inline bool NsJailConfig::has_time_limit() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void NsJailConfig::set_has_time_limit() {
  _has_bits_[1] |= 0x80000000u;
}
inline void NsJailConfig::clear_has_time_limit() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void NsJailConfig::clear_time_limit() {
  time_limit_ = 600u;
  clear_has_time_limit();
}
inline ::google::protobuf::uint32 NsJailConfig::time_limit() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.time_limit)
  return time_limit_;
}
inline void NsJailConfig::set_time_limit(::google::protobuf::uint32 value) {
  set_has_time_limit();
  time_limit_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.time_limit)
}

// optional bool daemon = 12 [default = false];
inline bool NsJailConfig::has_daemon() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void NsJailConfig::set_has_daemon() {
  _has_bits_[0] |= 0x08000000u;
}
inline void NsJailConfig::clear_has_daemon() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void NsJailConfig::clear_daemon() {
  daemon_ = false;
  clear_has_daemon();
}
inline bool NsJailConfig::daemon() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.daemon)
  return daemon_;
}
inline void NsJailConfig::set_daemon(bool value) {
  set_has_daemon();
  daemon_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.daemon)
}

// optional uint32 max_cpus = 13 [default = 0];
inline bool NsJailConfig::has_max_cpus() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NsJailConfig::set_has_max_cpus() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NsJailConfig::clear_has_max_cpus() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NsJailConfig::clear_max_cpus() {
  max_cpus_ = 0u;
  clear_has_max_cpus();
}
inline ::google::protobuf::uint32 NsJailConfig::max_cpus() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.max_cpus)
  return max_cpus_;
}
inline void NsJailConfig::set_max_cpus(::google::protobuf::uint32 value) {
  set_has_max_cpus();
  max_cpus_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.max_cpus)
}

// optional int32 log_fd = 14;
inline bool NsJailConfig::has_log_fd() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void NsJailConfig::set_has_log_fd() {
  _has_bits_[0] |= 0x40000000u;
}
inline void NsJailConfig::clear_has_log_fd() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void NsJailConfig::clear_log_fd() {
  log_fd_ = 0;
  clear_has_log_fd();
}
inline ::google::protobuf::int32 NsJailConfig::log_fd() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.log_fd)
  return log_fd_;
}
inline void NsJailConfig::set_log_fd(::google::protobuf::int32 value) {
  set_has_log_fd();
  log_fd_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.log_fd)
}

// optional string log_file = 15;
inline bool NsJailConfig::has_log_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NsJailConfig::set_has_log_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NsJailConfig::clear_has_log_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NsJailConfig::clear_log_file() {
  log_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_log_file();
}
inline const ::std::string& NsJailConfig::log_file() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.log_file)
  return log_file_.GetNoArena();
}
inline void NsJailConfig::set_log_file(const ::std::string& value) {
  set_has_log_file();
  log_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.log_file)
}
#if LANG_CXX11
inline void NsJailConfig::set_log_file(::std::string&& value) {
  set_has_log_file();
  log_file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.log_file)
}
#endif
inline void NsJailConfig::set_log_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_log_file();
  log_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.log_file)
}
inline void NsJailConfig::set_log_file(const char* value, size_t size) {
  set_has_log_file();
  log_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.log_file)
}
inline ::std::string* NsJailConfig::mutable_log_file() {
  set_has_log_file();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.log_file)
  return log_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NsJailConfig::release_log_file() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.log_file)
  if (!has_log_file()) {
    return NULL;
  }
  clear_has_log_file();
  return log_file_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NsJailConfig::set_allocated_log_file(::std::string* log_file) {
  if (log_file != NULL) {
    set_has_log_file();
  } else {
    clear_has_log_file();
  }
  log_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log_file);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.log_file)
}

// optional .nsjail.LogLevel log_level = 16;
inline bool NsJailConfig::has_log_level() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void NsJailConfig::set_has_log_level() {
  _has_bits_[0] |= 0x80000000u;
}
inline void NsJailConfig::clear_has_log_level() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void NsJailConfig::clear_log_level() {
  log_level_ = 0;
  clear_has_log_level();
}
inline ::nsjail::LogLevel NsJailConfig::log_level() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.log_level)
  return static_cast< ::nsjail::LogLevel >(log_level_);
}
inline void NsJailConfig::set_log_level(::nsjail::LogLevel value) {
  assert(::nsjail::LogLevel_IsValid(value));
  set_has_log_level();
  log_level_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.log_level)
}

// optional bool keep_env = 17 [default = false];
inline bool NsJailConfig::has_keep_env() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void NsJailConfig::set_has_keep_env() {
  _has_bits_[0] |= 0x10000000u;
}
inline void NsJailConfig::clear_has_keep_env() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void NsJailConfig::clear_keep_env() {
  keep_env_ = false;
  clear_has_keep_env();
}
inline bool NsJailConfig::keep_env() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.keep_env)
  return keep_env_;
}
inline void NsJailConfig::set_keep_env(bool value) {
  set_has_keep_env();
  keep_env_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.keep_env)
}

// repeated string envar = 18;
inline int NsJailConfig::envar_size() const {
  return envar_.size();
}
inline void NsJailConfig::clear_envar() {
  envar_.Clear();
}
inline const ::std::string& NsJailConfig::envar(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.envar)
  return envar_.Get(index);
}
inline ::std::string* NsJailConfig::mutable_envar(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.envar)
  return envar_.Mutable(index);
}
inline void NsJailConfig::set_envar(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.envar)
  envar_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NsJailConfig::set_envar(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.envar)
  envar_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NsJailConfig::set_envar(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  envar_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.envar)
}
inline void NsJailConfig::set_envar(int index, const char* value, size_t size) {
  envar_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.envar)
}
inline ::std::string* NsJailConfig::add_envar() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.envar)
  return envar_.Add();
}
inline void NsJailConfig::add_envar(const ::std::string& value) {
  envar_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.envar)
}
#if LANG_CXX11
inline void NsJailConfig::add_envar(::std::string&& value) {
  envar_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.envar)
}
#endif
inline void NsJailConfig::add_envar(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  envar_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.envar)
}
inline void NsJailConfig::add_envar(const char* value, size_t size) {
  envar_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.envar)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NsJailConfig::envar() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.envar)
  return envar_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NsJailConfig::mutable_envar() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.envar)
  return &envar_;
}

// optional bool keep_caps = 19 [default = false];
inline bool NsJailConfig::has_keep_caps() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void NsJailConfig::set_has_keep_caps() {
  _has_bits_[0] |= 0x20000000u;
}
inline void NsJailConfig::clear_has_keep_caps() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void NsJailConfig::clear_keep_caps() {
  keep_caps_ = false;
  clear_has_keep_caps();
}
inline bool NsJailConfig::keep_caps() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.keep_caps)
  return keep_caps_;
}
inline void NsJailConfig::set_keep_caps(bool value) {
  set_has_keep_caps();
  keep_caps_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.keep_caps)
}

// repeated string cap = 20;
inline int NsJailConfig::cap_size() const {
  return cap_.size();
}
inline void NsJailConfig::clear_cap() {
  cap_.Clear();
}
inline const ::std::string& NsJailConfig::cap(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cap)
  return cap_.Get(index);
}
inline ::std::string* NsJailConfig::mutable_cap(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cap)
  return cap_.Mutable(index);
}
inline void NsJailConfig::set_cap(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cap)
  cap_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NsJailConfig::set_cap(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cap)
  cap_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NsJailConfig::set_cap(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cap)
}
inline void NsJailConfig::set_cap(int index, const char* value, size_t size) {
  cap_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cap)
}
inline ::std::string* NsJailConfig::add_cap() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.cap)
  return cap_.Add();
}
inline void NsJailConfig::add_cap(const ::std::string& value) {
  cap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.cap)
}
#if LANG_CXX11
inline void NsJailConfig::add_cap(::std::string&& value) {
  cap_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.cap)
}
#endif
inline void NsJailConfig::add_cap(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.cap)
}
inline void NsJailConfig::add_cap(const char* value, size_t size) {
  cap_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.cap)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NsJailConfig::cap() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.cap)
  return cap_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NsJailConfig::mutable_cap() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.cap)
  return &cap_;
}

// optional bool silent = 21 [default = false];
inline bool NsJailConfig::has_silent() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void NsJailConfig::set_has_silent() {
  _has_bits_[1] |= 0x00000001u;
}
inline void NsJailConfig::clear_has_silent() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void NsJailConfig::clear_silent() {
  silent_ = false;
  clear_has_silent();
}
inline bool NsJailConfig::silent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.silent)
  return silent_;
}
inline void NsJailConfig::set_silent(bool value) {
  set_has_silent();
  silent_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.silent)
}

// optional bool skip_setsid = 22 [default = false];
inline bool NsJailConfig::has_skip_setsid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void NsJailConfig::set_has_skip_setsid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void NsJailConfig::clear_has_skip_setsid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void NsJailConfig::clear_skip_setsid() {
  skip_setsid_ = false;
  clear_has_skip_setsid();
}
inline bool NsJailConfig::skip_setsid() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.skip_setsid)
  return skip_setsid_;
}
inline void NsJailConfig::set_skip_setsid(bool value) {
  set_has_skip_setsid();
  skip_setsid_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.skip_setsid)
}

// optional bool stderr_to_null = 23 [default = false];
inline bool NsJailConfig::has_stderr_to_null() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void NsJailConfig::set_has_stderr_to_null() {
  _has_bits_[1] |= 0x00000004u;
}
inline void NsJailConfig::clear_has_stderr_to_null() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void NsJailConfig::clear_stderr_to_null() {
  stderr_to_null_ = false;
  clear_has_stderr_to_null();
}
inline bool NsJailConfig::stderr_to_null() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.stderr_to_null)
  return stderr_to_null_;
}
inline void NsJailConfig::set_stderr_to_null(bool value) {
  set_has_stderr_to_null();
  stderr_to_null_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.stderr_to_null)
}

// repeated int32 pass_fd = 24;
inline int NsJailConfig::pass_fd_size() const {
  return pass_fd_.size();
}
inline void NsJailConfig::clear_pass_fd() {
  pass_fd_.Clear();
}
inline ::google::protobuf::int32 NsJailConfig::pass_fd(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.pass_fd)
  return pass_fd_.Get(index);
}
inline void NsJailConfig::set_pass_fd(int index, ::google::protobuf::int32 value) {
  pass_fd_.Set(index, value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.pass_fd)
}
inline void NsJailConfig::add_pass_fd(::google::protobuf::int32 value) {
  pass_fd_.Add(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.pass_fd)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NsJailConfig::pass_fd() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.pass_fd)
  return pass_fd_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NsJailConfig::mutable_pass_fd() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.pass_fd)
  return &pass_fd_;
}

// optional bool disable_no_new_privs = 25 [default = false];
inline bool NsJailConfig::has_disable_no_new_privs() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void NsJailConfig::set_has_disable_no_new_privs() {
  _has_bits_[1] |= 0x00000008u;
}
inline void NsJailConfig::clear_has_disable_no_new_privs() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void NsJailConfig::clear_disable_no_new_privs() {
  disable_no_new_privs_ = false;
  clear_has_disable_no_new_privs();
}
inline bool NsJailConfig::disable_no_new_privs() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.disable_no_new_privs)
  return disable_no_new_privs_;
}
inline void NsJailConfig::set_disable_no_new_privs(bool value) {
  set_has_disable_no_new_privs();
  disable_no_new_privs_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.disable_no_new_privs)
}

// optional uint64 rlimit_as = 26 [default = 4096];
inline bool NsJailConfig::has_rlimit_as() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void NsJailConfig::set_has_rlimit_as() {
  _has_bits_[2] |= 0x00000001u;
}
inline void NsJailConfig::clear_has_rlimit_as() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void NsJailConfig::clear_rlimit_as() {
  rlimit_as_ = GOOGLE_ULONGLONG(4096);
  clear_has_rlimit_as();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_as() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_as)
  return rlimit_as_;
}
inline void NsJailConfig::set_rlimit_as(::google::protobuf::uint64 value) {
  set_has_rlimit_as();
  rlimit_as_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_as)
}

// optional .nsjail.RLimit rlimit_as_type = 27 [default = VALUE];
inline bool NsJailConfig::has_rlimit_as_type() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void NsJailConfig::set_has_rlimit_as_type() {
  _has_bits_[1] |= 0x00000020u;
}
inline void NsJailConfig::clear_has_rlimit_as_type() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void NsJailConfig::clear_rlimit_as_type() {
  rlimit_as_type_ = 0;
  clear_has_rlimit_as_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_as_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_as_type)
  return static_cast< ::nsjail::RLimit >(rlimit_as_type_);
}
inline void NsJailConfig::set_rlimit_as_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_as_type();
  rlimit_as_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_as_type)
}

// optional uint64 rlimit_core = 28 [default = 0];
inline bool NsJailConfig::has_rlimit_core() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void NsJailConfig::set_has_rlimit_core() {
  _has_bits_[1] |= 0x00000010u;
}
inline void NsJailConfig::clear_has_rlimit_core() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void NsJailConfig::clear_rlimit_core() {
  rlimit_core_ = GOOGLE_ULONGLONG(0);
  clear_has_rlimit_core();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_core() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_core)
  return rlimit_core_;
}
inline void NsJailConfig::set_rlimit_core(::google::protobuf::uint64 value) {
  set_has_rlimit_core();
  rlimit_core_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_core)
}

// optional .nsjail.RLimit rlimit_core_type = 29 [default = VALUE];
inline bool NsJailConfig::has_rlimit_core_type() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void NsJailConfig::set_has_rlimit_core_type() {
  _has_bits_[1] |= 0x00000040u;
}
inline void NsJailConfig::clear_has_rlimit_core_type() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void NsJailConfig::clear_rlimit_core_type() {
  rlimit_core_type_ = 0;
  clear_has_rlimit_core_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_core_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_core_type)
  return static_cast< ::nsjail::RLimit >(rlimit_core_type_);
}
inline void NsJailConfig::set_rlimit_core_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_core_type();
  rlimit_core_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_core_type)
}

// optional uint64 rlimit_cpu = 30 [default = 600];
inline bool NsJailConfig::has_rlimit_cpu() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void NsJailConfig::set_has_rlimit_cpu() {
  _has_bits_[2] |= 0x00000002u;
}
inline void NsJailConfig::clear_has_rlimit_cpu() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void NsJailConfig::clear_rlimit_cpu() {
  rlimit_cpu_ = GOOGLE_ULONGLONG(600);
  clear_has_rlimit_cpu();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_cpu() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_cpu)
  return rlimit_cpu_;
}
inline void NsJailConfig::set_rlimit_cpu(::google::protobuf::uint64 value) {
  set_has_rlimit_cpu();
  rlimit_cpu_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_cpu)
}

// optional .nsjail.RLimit rlimit_cpu_type = 31 [default = VALUE];
inline bool NsJailConfig::has_rlimit_cpu_type() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void NsJailConfig::set_has_rlimit_cpu_type() {
  _has_bits_[1] |= 0x00000080u;
}
inline void NsJailConfig::clear_has_rlimit_cpu_type() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void NsJailConfig::clear_rlimit_cpu_type() {
  rlimit_cpu_type_ = 0;
  clear_has_rlimit_cpu_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_cpu_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_cpu_type)
  return static_cast< ::nsjail::RLimit >(rlimit_cpu_type_);
}
inline void NsJailConfig::set_rlimit_cpu_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_cpu_type();
  rlimit_cpu_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_cpu_type)
}

// optional uint64 rlimit_fsize = 32 [default = 1];
inline bool NsJailConfig::has_rlimit_fsize() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void NsJailConfig::set_has_rlimit_fsize() {
  _has_bits_[2] |= 0x00000004u;
}
inline void NsJailConfig::clear_has_rlimit_fsize() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void NsJailConfig::clear_rlimit_fsize() {
  rlimit_fsize_ = GOOGLE_ULONGLONG(1);
  clear_has_rlimit_fsize();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_fsize() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_fsize)
  return rlimit_fsize_;
}
inline void NsJailConfig::set_rlimit_fsize(::google::protobuf::uint64 value) {
  set_has_rlimit_fsize();
  rlimit_fsize_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_fsize)
}

// optional .nsjail.RLimit rlimit_fsize_type = 33 [default = VALUE];
inline bool NsJailConfig::has_rlimit_fsize_type() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void NsJailConfig::set_has_rlimit_fsize_type() {
  _has_bits_[1] |= 0x00000100u;
}
inline void NsJailConfig::clear_has_rlimit_fsize_type() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void NsJailConfig::clear_rlimit_fsize_type() {
  rlimit_fsize_type_ = 0;
  clear_has_rlimit_fsize_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_fsize_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_fsize_type)
  return static_cast< ::nsjail::RLimit >(rlimit_fsize_type_);
}
inline void NsJailConfig::set_rlimit_fsize_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_fsize_type();
  rlimit_fsize_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_fsize_type)
}

// optional uint64 rlimit_nofile = 34 [default = 32];
inline bool NsJailConfig::has_rlimit_nofile() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void NsJailConfig::set_has_rlimit_nofile() {
  _has_bits_[2] |= 0x00000008u;
}
inline void NsJailConfig::clear_has_rlimit_nofile() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void NsJailConfig::clear_rlimit_nofile() {
  rlimit_nofile_ = GOOGLE_ULONGLONG(32);
  clear_has_rlimit_nofile();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_nofile() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_nofile)
  return rlimit_nofile_;
}
inline void NsJailConfig::set_rlimit_nofile(::google::protobuf::uint64 value) {
  set_has_rlimit_nofile();
  rlimit_nofile_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_nofile)
}

// optional .nsjail.RLimit rlimit_nofile_type = 35 [default = VALUE];
inline bool NsJailConfig::has_rlimit_nofile_type() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void NsJailConfig::set_has_rlimit_nofile_type() {
  _has_bits_[1] |= 0x00000400u;
}
inline void NsJailConfig::clear_has_rlimit_nofile_type() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void NsJailConfig::clear_rlimit_nofile_type() {
  rlimit_nofile_type_ = 0;
  clear_has_rlimit_nofile_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_nofile_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_nofile_type)
  return static_cast< ::nsjail::RLimit >(rlimit_nofile_type_);
}
inline void NsJailConfig::set_rlimit_nofile_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_nofile_type();
  rlimit_nofile_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_nofile_type)
}

// optional uint64 rlimit_nproc = 36 [default = 1024];
inline bool NsJailConfig::has_rlimit_nproc() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void NsJailConfig::set_has_rlimit_nproc() {
  _has_bits_[2] |= 0x00000010u;
}
inline void NsJailConfig::clear_has_rlimit_nproc() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void NsJailConfig::clear_rlimit_nproc() {
  rlimit_nproc_ = GOOGLE_ULONGLONG(1024);
  clear_has_rlimit_nproc();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_nproc() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_nproc)
  return rlimit_nproc_;
}
inline void NsJailConfig::set_rlimit_nproc(::google::protobuf::uint64 value) {
  set_has_rlimit_nproc();
  rlimit_nproc_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_nproc)
}

// optional .nsjail.RLimit rlimit_nproc_type = 37 [default = SOFT];
inline bool NsJailConfig::has_rlimit_nproc_type() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void NsJailConfig::set_has_rlimit_nproc_type() {
  _has_bits_[2] |= 0x00000040u;
}
inline void NsJailConfig::clear_has_rlimit_nproc_type() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void NsJailConfig::clear_rlimit_nproc_type() {
  rlimit_nproc_type_ = 1;
  clear_has_rlimit_nproc_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_nproc_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_nproc_type)
  return static_cast< ::nsjail::RLimit >(rlimit_nproc_type_);
}
inline void NsJailConfig::set_rlimit_nproc_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_nproc_type();
  rlimit_nproc_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_nproc_type)
}

// optional uint64 rlimit_stack = 38 [default = 8];
inline bool NsJailConfig::has_rlimit_stack() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void NsJailConfig::set_has_rlimit_stack() {
  _has_bits_[2] |= 0x00000020u;
}
inline void NsJailConfig::clear_has_rlimit_stack() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void NsJailConfig::clear_rlimit_stack() {
  rlimit_stack_ = GOOGLE_ULONGLONG(8);
  clear_has_rlimit_stack();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_stack() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_stack)
  return rlimit_stack_;
}
inline void NsJailConfig::set_rlimit_stack(::google::protobuf::uint64 value) {
  set_has_rlimit_stack();
  rlimit_stack_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_stack)
}

// optional .nsjail.RLimit rlimit_stack_type = 39 [default = SOFT];
inline bool NsJailConfig::has_rlimit_stack_type() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void NsJailConfig::set_has_rlimit_stack_type() {
  _has_bits_[2] |= 0x00000080u;
}
inline void NsJailConfig::clear_has_rlimit_stack_type() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void NsJailConfig::clear_rlimit_stack_type() {
  rlimit_stack_type_ = 1;
  clear_has_rlimit_stack_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_stack_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_stack_type)
  return static_cast< ::nsjail::RLimit >(rlimit_stack_type_);
}
inline void NsJailConfig::set_rlimit_stack_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_stack_type();
  rlimit_stack_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_stack_type)
}

// optional uint64 rlimit_memlock = 40 [default = 64];
inline bool NsJailConfig::has_rlimit_memlock() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void NsJailConfig::set_has_rlimit_memlock() {
  _has_bits_[2] |= 0x00000100u;
}
inline void NsJailConfig::clear_has_rlimit_memlock() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void NsJailConfig::clear_rlimit_memlock() {
  rlimit_memlock_ = GOOGLE_ULONGLONG(64);
  clear_has_rlimit_memlock();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_memlock() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_memlock)
  return rlimit_memlock_;
}
inline void NsJailConfig::set_rlimit_memlock(::google::protobuf::uint64 value) {
  set_has_rlimit_memlock();
  rlimit_memlock_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_memlock)
}

// optional .nsjail.RLimit rlimit_memlock_type = 41 [default = SOFT];
inline bool NsJailConfig::has_rlimit_memlock_type() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void NsJailConfig::set_has_rlimit_memlock_type() {
  _has_bits_[2] |= 0x00000200u;
}
inline void NsJailConfig::clear_has_rlimit_memlock_type() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void NsJailConfig::clear_rlimit_memlock_type() {
  rlimit_memlock_type_ = 1;
  clear_has_rlimit_memlock_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_memlock_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_memlock_type)
  return static_cast< ::nsjail::RLimit >(rlimit_memlock_type_);
}
inline void NsJailConfig::set_rlimit_memlock_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_memlock_type();
  rlimit_memlock_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_memlock_type)
}

// optional uint64 rlimit_rtprio = 42 [default = 0];
inline bool NsJailConfig::has_rlimit_rtprio() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void NsJailConfig::set_has_rlimit_rtprio() {
  _has_bits_[1] |= 0x00000200u;
}
inline void NsJailConfig::clear_has_rlimit_rtprio() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void NsJailConfig::clear_rlimit_rtprio() {
  rlimit_rtprio_ = GOOGLE_ULONGLONG(0);
  clear_has_rlimit_rtprio();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_rtprio() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_rtprio)
  return rlimit_rtprio_;
}
inline void NsJailConfig::set_rlimit_rtprio(::google::protobuf::uint64 value) {
  set_has_rlimit_rtprio();
  rlimit_rtprio_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_rtprio)
}

// optional .nsjail.RLimit rlimit_rtprio_type = 43 [default = SOFT];
inline bool NsJailConfig::has_rlimit_rtprio_type() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void NsJailConfig::set_has_rlimit_rtprio_type() {
  _has_bits_[2] |= 0x00000400u;
}
inline void NsJailConfig::clear_has_rlimit_rtprio_type() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void NsJailConfig::clear_rlimit_rtprio_type() {
  rlimit_rtprio_type_ = 1;
  clear_has_rlimit_rtprio_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_rtprio_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_rtprio_type)
  return static_cast< ::nsjail::RLimit >(rlimit_rtprio_type_);
}
inline void NsJailConfig::set_rlimit_rtprio_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_rtprio_type();
  rlimit_rtprio_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_rtprio_type)
}

// optional uint64 rlimit_msgqueue = 44 [default = 1024];
inline bool NsJailConfig::has_rlimit_msgqueue() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void NsJailConfig::set_has_rlimit_msgqueue() {
  _has_bits_[2] |= 0x00000800u;
}
inline void NsJailConfig::clear_has_rlimit_msgqueue() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void NsJailConfig::clear_rlimit_msgqueue() {
  rlimit_msgqueue_ = GOOGLE_ULONGLONG(1024);
  clear_has_rlimit_msgqueue();
}
inline ::google::protobuf::uint64 NsJailConfig::rlimit_msgqueue() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_msgqueue)
  return rlimit_msgqueue_;
}
inline void NsJailConfig::set_rlimit_msgqueue(::google::protobuf::uint64 value) {
  set_has_rlimit_msgqueue();
  rlimit_msgqueue_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_msgqueue)
}

// optional .nsjail.RLimit rlimit_msgqueue_type = 45 [default = SOFT];
inline bool NsJailConfig::has_rlimit_msgqueue_type() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void NsJailConfig::set_has_rlimit_msgqueue_type() {
  _has_bits_[2] |= 0x00001000u;
}
inline void NsJailConfig::clear_has_rlimit_msgqueue_type() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void NsJailConfig::clear_rlimit_msgqueue_type() {
  rlimit_msgqueue_type_ = 1;
  clear_has_rlimit_msgqueue_type();
}
inline ::nsjail::RLimit NsJailConfig::rlimit_msgqueue_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_msgqueue_type)
  return static_cast< ::nsjail::RLimit >(rlimit_msgqueue_type_);
}
inline void NsJailConfig::set_rlimit_msgqueue_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  set_has_rlimit_msgqueue_type();
  rlimit_msgqueue_type_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_msgqueue_type)
}

// optional bool disable_rl = 46 [default = false];
inline bool NsJailConfig::has_disable_rl() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void NsJailConfig::set_has_disable_rl() {
  _has_bits_[1] |= 0x00000800u;
}
inline void NsJailConfig::clear_has_disable_rl() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void NsJailConfig::clear_disable_rl() {
  disable_rl_ = false;
  clear_has_disable_rl();
}
inline bool NsJailConfig::disable_rl() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.disable_rl)
  return disable_rl_;
}
inline void NsJailConfig::set_disable_rl(bool value) {
  set_has_disable_rl();
  disable_rl_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.disable_rl)
}

// optional bool persona_addr_compat_layout = 47 [default = false];
inline bool NsJailConfig::has_persona_addr_compat_layout() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void NsJailConfig::set_has_persona_addr_compat_layout() {
  _has_bits_[1] |= 0x00001000u;
}
inline void NsJailConfig::clear_has_persona_addr_compat_layout() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void NsJailConfig::clear_persona_addr_compat_layout() {
  persona_addr_compat_layout_ = false;
  clear_has_persona_addr_compat_layout();
}
inline bool NsJailConfig::persona_addr_compat_layout() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_addr_compat_layout)
  return persona_addr_compat_layout_;
}
inline void NsJailConfig::set_persona_addr_compat_layout(bool value) {
  set_has_persona_addr_compat_layout();
  persona_addr_compat_layout_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_addr_compat_layout)
}

// optional bool persona_mmap_page_zero = 48 [default = false];
inline bool NsJailConfig::has_persona_mmap_page_zero() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void NsJailConfig::set_has_persona_mmap_page_zero() {
  _has_bits_[1] |= 0x00002000u;
}
inline void NsJailConfig::clear_has_persona_mmap_page_zero() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void NsJailConfig::clear_persona_mmap_page_zero() {
  persona_mmap_page_zero_ = false;
  clear_has_persona_mmap_page_zero();
}
inline bool NsJailConfig::persona_mmap_page_zero() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_mmap_page_zero)
  return persona_mmap_page_zero_;
}
inline void NsJailConfig::set_persona_mmap_page_zero(bool value) {
  set_has_persona_mmap_page_zero();
  persona_mmap_page_zero_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_mmap_page_zero)
}

// optional bool persona_read_implies_exec = 49 [default = false];
inline bool NsJailConfig::has_persona_read_implies_exec() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void NsJailConfig::set_has_persona_read_implies_exec() {
  _has_bits_[1] |= 0x00004000u;
}
inline void NsJailConfig::clear_has_persona_read_implies_exec() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void NsJailConfig::clear_persona_read_implies_exec() {
  persona_read_implies_exec_ = false;
  clear_has_persona_read_implies_exec();
}
inline bool NsJailConfig::persona_read_implies_exec() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_read_implies_exec)
  return persona_read_implies_exec_;
}
inline void NsJailConfig::set_persona_read_implies_exec(bool value) {
  set_has_persona_read_implies_exec();
  persona_read_implies_exec_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_read_implies_exec)
}

// optional bool persona_addr_limit_3gb = 50 [default = false];
inline bool NsJailConfig::has_persona_addr_limit_3gb() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void NsJailConfig::set_has_persona_addr_limit_3gb() {
  _has_bits_[1] |= 0x00008000u;
}
inline void NsJailConfig::clear_has_persona_addr_limit_3gb() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void NsJailConfig::clear_persona_addr_limit_3gb() {
  persona_addr_limit_3gb_ = false;
  clear_has_persona_addr_limit_3gb();
}
inline bool NsJailConfig::persona_addr_limit_3gb() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_addr_limit_3gb)
  return persona_addr_limit_3gb_;
}
inline void NsJailConfig::set_persona_addr_limit_3gb(bool value) {
  set_has_persona_addr_limit_3gb();
  persona_addr_limit_3gb_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_addr_limit_3gb)
}

// optional bool persona_addr_no_randomize = 51 [default = false];
inline bool NsJailConfig::has_persona_addr_no_randomize() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void NsJailConfig::set_has_persona_addr_no_randomize() {
  _has_bits_[1] |= 0x00010000u;
}
inline void NsJailConfig::clear_has_persona_addr_no_randomize() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void NsJailConfig::clear_persona_addr_no_randomize() {
  persona_addr_no_randomize_ = false;
  clear_has_persona_addr_no_randomize();
}
inline bool NsJailConfig::persona_addr_no_randomize() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_addr_no_randomize)
  return persona_addr_no_randomize_;
}
inline void NsJailConfig::set_persona_addr_no_randomize(bool value) {
  set_has_persona_addr_no_randomize();
  persona_addr_no_randomize_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_addr_no_randomize)
}

// optional bool clone_newnet = 52 [default = true];
inline bool NsJailConfig::has_clone_newnet() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void NsJailConfig::set_has_clone_newnet() {
  _has_bits_[2] |= 0x00002000u;
}
inline void NsJailConfig::clear_has_clone_newnet() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void NsJailConfig::clear_clone_newnet() {
  clone_newnet_ = true;
  clear_has_clone_newnet();
}
inline bool NsJailConfig::clone_newnet() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newnet)
  return clone_newnet_;
}
inline void NsJailConfig::set_clone_newnet(bool value) {
  set_has_clone_newnet();
  clone_newnet_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newnet)
}

// optional bool clone_newuser = 53 [default = true];
inline bool NsJailConfig::has_clone_newuser() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void NsJailConfig::set_has_clone_newuser() {
  _has_bits_[2] |= 0x00004000u;
}
inline void NsJailConfig::clear_has_clone_newuser() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void NsJailConfig::clear_clone_newuser() {
  clone_newuser_ = true;
  clear_has_clone_newuser();
}
inline bool NsJailConfig::clone_newuser() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newuser)
  return clone_newuser_;
}
inline void NsJailConfig::set_clone_newuser(bool value) {
  set_has_clone_newuser();
  clone_newuser_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newuser)
}

// optional bool clone_newns = 54 [default = true];
inline bool NsJailConfig::has_clone_newns() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void NsJailConfig::set_has_clone_newns() {
  _has_bits_[2] |= 0x00008000u;
}
inline void NsJailConfig::clear_has_clone_newns() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void NsJailConfig::clear_clone_newns() {
  clone_newns_ = true;
  clear_has_clone_newns();
}
inline bool NsJailConfig::clone_newns() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newns)
  return clone_newns_;
}
inline void NsJailConfig::set_clone_newns(bool value) {
  set_has_clone_newns();
  clone_newns_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newns)
}

// optional bool clone_newpid = 55 [default = true];
inline bool NsJailConfig::has_clone_newpid() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void NsJailConfig::set_has_clone_newpid() {
  _has_bits_[2] |= 0x00010000u;
}
inline void NsJailConfig::clear_has_clone_newpid() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void NsJailConfig::clear_clone_newpid() {
  clone_newpid_ = true;
  clear_has_clone_newpid();
}
inline bool NsJailConfig::clone_newpid() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newpid)
  return clone_newpid_;
}
inline void NsJailConfig::set_clone_newpid(bool value) {
  set_has_clone_newpid();
  clone_newpid_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newpid)
}

// optional bool clone_newipc = 56 [default = true];
inline bool NsJailConfig::has_clone_newipc() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void NsJailConfig::set_has_clone_newipc() {
  _has_bits_[2] |= 0x00020000u;
}
inline void NsJailConfig::clear_has_clone_newipc() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void NsJailConfig::clear_clone_newipc() {
  clone_newipc_ = true;
  clear_has_clone_newipc();
}
inline bool NsJailConfig::clone_newipc() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newipc)
  return clone_newipc_;
}
inline void NsJailConfig::set_clone_newipc(bool value) {
  set_has_clone_newipc();
  clone_newipc_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newipc)
}

// optional bool clone_newuts = 57 [default = true];
inline bool NsJailConfig::has_clone_newuts() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void NsJailConfig::set_has_clone_newuts() {
  _has_bits_[2] |= 0x00040000u;
}
inline void NsJailConfig::clear_has_clone_newuts() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void NsJailConfig::clear_clone_newuts() {
  clone_newuts_ = true;
  clear_has_clone_newuts();
}
inline bool NsJailConfig::clone_newuts() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newuts)
  return clone_newuts_;
}
inline void NsJailConfig::set_clone_newuts(bool value) {
  set_has_clone_newuts();
  clone_newuts_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newuts)
}

// optional bool clone_newcgroup = 58 [default = true];
inline bool NsJailConfig::has_clone_newcgroup() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void NsJailConfig::set_has_clone_newcgroup() {
  _has_bits_[2] |= 0x00080000u;
}
inline void NsJailConfig::clear_has_clone_newcgroup() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void NsJailConfig::clear_clone_newcgroup() {
  clone_newcgroup_ = true;
  clear_has_clone_newcgroup();
}
inline bool NsJailConfig::clone_newcgroup() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newcgroup)
  return clone_newcgroup_;
}
inline void NsJailConfig::set_clone_newcgroup(bool value) {
  set_has_clone_newcgroup();
  clone_newcgroup_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newcgroup)
}

// optional bool clone_newtime = 59 [default = false];
inline bool NsJailConfig::has_clone_newtime() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void NsJailConfig::set_has_clone_newtime() {
  _has_bits_[1] |= 0x00020000u;
}
inline void NsJailConfig::clear_has_clone_newtime() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void NsJailConfig::clear_clone_newtime() {
  clone_newtime_ = false;
  clear_has_clone_newtime();
}
inline bool NsJailConfig::clone_newtime() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newtime)
  return clone_newtime_;
}
inline void NsJailConfig::set_clone_newtime(bool value) {
  set_has_clone_newtime();
  clone_newtime_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newtime)
}

// repeated .nsjail.IdMap uidmap = 60;
inline int NsJailConfig::uidmap_size() const {
  return uidmap_.size();
}
inline void NsJailConfig::clear_uidmap() {
  uidmap_.Clear();
}
inline ::nsjail::IdMap* NsJailConfig::mutable_uidmap(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.uidmap)
  return uidmap_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap >*
NsJailConfig::mutable_uidmap() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.uidmap)
  return &uidmap_;
}
inline const ::nsjail::IdMap& NsJailConfig::uidmap(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.uidmap)
  return uidmap_.Get(index);
}
inline ::nsjail::IdMap* NsJailConfig::add_uidmap() {
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.uidmap)
  return uidmap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap >&
NsJailConfig::uidmap() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.uidmap)
  return uidmap_;
}

// repeated .nsjail.IdMap gidmap = 61;
inline int NsJailConfig::gidmap_size() const {
  return gidmap_.size();
}
inline void NsJailConfig::clear_gidmap() {
  gidmap_.Clear();
}
inline ::nsjail::IdMap* NsJailConfig::mutable_gidmap(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.gidmap)
  return gidmap_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap >*
NsJailConfig::mutable_gidmap() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.gidmap)
  return &gidmap_;
}
inline const ::nsjail::IdMap& NsJailConfig::gidmap(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.gidmap)
  return gidmap_.Get(index);
}
inline ::nsjail::IdMap* NsJailConfig::add_gidmap() {
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.gidmap)
  return gidmap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsjail::IdMap >&
NsJailConfig::gidmap() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.gidmap)
  return gidmap_;
}

// optional bool mount_proc = 62 [default = false];
inline bool NsJailConfig::has_mount_proc() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void NsJailConfig::set_has_mount_proc() {
  _has_bits_[1] |= 0x00040000u;
}
inline void NsJailConfig::clear_has_mount_proc() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void NsJailConfig::clear_mount_proc() {
  mount_proc_ = false;
  clear_has_mount_proc();
}
inline bool NsJailConfig::mount_proc() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.mount_proc)
  return mount_proc_;
}
inline void NsJailConfig::set_mount_proc(bool value) {
  set_has_mount_proc();
  mount_proc_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.mount_proc)
}

// repeated .nsjail.MountPt mount = 63;
inline int NsJailConfig::mount_size() const {
  return mount_.size();
}
inline void NsJailConfig::clear_mount() {
  mount_.Clear();
}
inline ::nsjail::MountPt* NsJailConfig::mutable_mount(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.mount)
  return mount_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nsjail::MountPt >*
NsJailConfig::mutable_mount() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.mount)
  return &mount_;
}
inline const ::nsjail::MountPt& NsJailConfig::mount(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.mount)
  return mount_.Get(index);
}
inline ::nsjail::MountPt* NsJailConfig::add_mount() {
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.mount)
  return mount_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsjail::MountPt >&
NsJailConfig::mount() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.mount)
  return mount_;
}

// optional string seccomp_policy_file = 64;
inline bool NsJailConfig::has_seccomp_policy_file() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NsJailConfig::set_has_seccomp_policy_file() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NsJailConfig::clear_has_seccomp_policy_file() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NsJailConfig::clear_seccomp_policy_file() {
  seccomp_policy_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seccomp_policy_file();
}
inline const ::std::string& NsJailConfig::seccomp_policy_file() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.seccomp_policy_file)
  return seccomp_policy_file_.GetNoArena();
}
inline void NsJailConfig::set_seccomp_policy_file(const ::std::string& value) {
  set_has_seccomp_policy_file();
  seccomp_policy_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.seccomp_policy_file)
}
#if LANG_CXX11
inline void NsJailConfig::set_seccomp_policy_file(::std::string&& value) {
  set_has_seccomp_policy_file();
  seccomp_policy_file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.seccomp_policy_file)
}
#endif
inline void NsJailConfig::set_seccomp_policy_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seccomp_policy_file();
  seccomp_policy_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.seccomp_policy_file)
}
inline void NsJailConfig::set_seccomp_policy_file(const char* value, size_t size) {
  set_has_seccomp_policy_file();
  seccomp_policy_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.seccomp_policy_file)
}
inline ::std::string* NsJailConfig::mutable_seccomp_policy_file() {
  set_has_seccomp_policy_file();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.seccomp_policy_file)
  return seccomp_policy_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NsJailConfig::release_seccomp_policy_file() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.seccomp_policy_file)
  if (!has_seccomp_policy_file()) {
    return NULL;
  }
  clear_has_seccomp_policy_file();
  return seccomp_policy_file_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NsJailConfig::set_allocated_seccomp_policy_file(::std::string* seccomp_policy_file) {
  if (seccomp_policy_file != NULL) {
    set_has_seccomp_policy_file();
  } else {
    clear_has_seccomp_policy_file();
  }
  seccomp_policy_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seccomp_policy_file);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.seccomp_policy_file)
}

// repeated string seccomp_string = 65;
inline int NsJailConfig::seccomp_string_size() const {
  return seccomp_string_.size();
}
inline void NsJailConfig::clear_seccomp_string() {
  seccomp_string_.Clear();
}
inline const ::std::string& NsJailConfig::seccomp_string(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.seccomp_string)
  return seccomp_string_.Get(index);
}
inline ::std::string* NsJailConfig::mutable_seccomp_string(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.seccomp_string)
  return seccomp_string_.Mutable(index);
}
inline void NsJailConfig::set_seccomp_string(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.seccomp_string)
  seccomp_string_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NsJailConfig::set_seccomp_string(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.seccomp_string)
  seccomp_string_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NsJailConfig::set_seccomp_string(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  seccomp_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.seccomp_string)
}
inline void NsJailConfig::set_seccomp_string(int index, const char* value, size_t size) {
  seccomp_string_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.seccomp_string)
}
inline ::std::string* NsJailConfig::add_seccomp_string() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.seccomp_string)
  return seccomp_string_.Add();
}
inline void NsJailConfig::add_seccomp_string(const ::std::string& value) {
  seccomp_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.seccomp_string)
}
#if LANG_CXX11
inline void NsJailConfig::add_seccomp_string(::std::string&& value) {
  seccomp_string_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.seccomp_string)
}
#endif
inline void NsJailConfig::add_seccomp_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  seccomp_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.seccomp_string)
}
inline void NsJailConfig::add_seccomp_string(const char* value, size_t size) {
  seccomp_string_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.seccomp_string)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NsJailConfig::seccomp_string() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.seccomp_string)
  return seccomp_string_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NsJailConfig::mutable_seccomp_string() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.seccomp_string)
  return &seccomp_string_;
}

// optional bool seccomp_log = 66 [default = false];
inline bool NsJailConfig::has_seccomp_log() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void NsJailConfig::set_has_seccomp_log() {
  _has_bits_[1] |= 0x00800000u;
}
inline void NsJailConfig::clear_has_seccomp_log() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void NsJailConfig::clear_seccomp_log() {
  seccomp_log_ = false;
  clear_has_seccomp_log();
}
inline bool NsJailConfig::seccomp_log() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.seccomp_log)
  return seccomp_log_;
}
inline void NsJailConfig::set_seccomp_log(bool value) {
  set_has_seccomp_log();
  seccomp_log_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.seccomp_log)
}

// optional uint64 cgroup_mem_max = 67 [default = 0];
inline bool NsJailConfig::has_cgroup_mem_max() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void NsJailConfig::set_has_cgroup_mem_max() {
  _has_bits_[1] |= 0x00100000u;
}
inline void NsJailConfig::clear_has_cgroup_mem_max() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void NsJailConfig::clear_cgroup_mem_max() {
  cgroup_mem_max_ = GOOGLE_ULONGLONG(0);
  clear_has_cgroup_mem_max();
}
inline ::google::protobuf::uint64 NsJailConfig::cgroup_mem_max() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_mem_max)
  return cgroup_mem_max_;
}
inline void NsJailConfig::set_cgroup_mem_max(::google::protobuf::uint64 value) {
  set_has_cgroup_mem_max();
  cgroup_mem_max_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_mem_max)
}

// optional uint64 cgroup_mem_memsw_max = 91 [default = 0];
inline bool NsJailConfig::has_cgroup_mem_memsw_max() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void NsJailConfig::set_has_cgroup_mem_memsw_max() {
  _has_bits_[1] |= 0x08000000u;
}
inline void NsJailConfig::clear_has_cgroup_mem_memsw_max() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void NsJailConfig::clear_cgroup_mem_memsw_max() {
  cgroup_mem_memsw_max_ = GOOGLE_ULONGLONG(0);
  clear_has_cgroup_mem_memsw_max();
}
inline ::google::protobuf::uint64 NsJailConfig::cgroup_mem_memsw_max() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_mem_memsw_max)
  return cgroup_mem_memsw_max_;
}
inline void NsJailConfig::set_cgroup_mem_memsw_max(::google::protobuf::uint64 value) {
  set_has_cgroup_mem_memsw_max();
  cgroup_mem_memsw_max_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_mem_memsw_max)
}

// optional int64 cgroup_mem_swap_max = 92 [default = -1];
inline bool NsJailConfig::has_cgroup_mem_swap_max() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void NsJailConfig::set_has_cgroup_mem_swap_max() {
  _has_bits_[2] |= 0x00200000u;
}
inline void NsJailConfig::clear_has_cgroup_mem_swap_max() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void NsJailConfig::clear_cgroup_mem_swap_max() {
  cgroup_mem_swap_max_ = GOOGLE_LONGLONG(-1);
  clear_has_cgroup_mem_swap_max();
}
inline ::google::protobuf::int64 NsJailConfig::cgroup_mem_swap_max() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_mem_swap_max)
  return cgroup_mem_swap_max_;
}
inline void NsJailConfig::set_cgroup_mem_swap_max(::google::protobuf::int64 value) {
  set_has_cgroup_mem_swap_max();
  cgroup_mem_swap_max_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_mem_swap_max)
}

// optional string cgroup_mem_mount = 68 [default = "/sys/fs/cgroup/memory"];
inline bool NsJailConfig::has_cgroup_mem_mount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NsJailConfig::set_has_cgroup_mem_mount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NsJailConfig::clear_has_cgroup_mem_mount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NsJailConfig::clear_cgroup_mem_mount() {
  cgroup_mem_mount_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get());
  clear_has_cgroup_mem_mount();
}
inline const ::std::string& NsJailConfig::cgroup_mem_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_mem_mount)
  return cgroup_mem_mount_.GetNoArena();
}
inline void NsJailConfig::set_cgroup_mem_mount(const ::std::string& value) {
  set_has_cgroup_mem_mount();
  cgroup_mem_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_mem_mount)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroup_mem_mount(::std::string&& value) {
  set_has_cgroup_mem_mount();
  cgroup_mem_mount_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_mem_mount)
}
#endif
inline void NsJailConfig::set_cgroup_mem_mount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroup_mem_mount();
  cgroup_mem_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_mem_mount)
}
inline void NsJailConfig::set_cgroup_mem_mount(const char* value, size_t size) {
  set_has_cgroup_mem_mount();
  cgroup_mem_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_mem_mount)
}
inline ::std::string* NsJailConfig::mutable_cgroup_mem_mount() {
  set_has_cgroup_mem_mount();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_mem_mount)
  return cgroup_mem_mount_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get());
}
inline ::std::string* NsJailConfig::release_cgroup_mem_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_mem_mount)
  if (!has_cgroup_mem_mount()) {
    return NULL;
  }
  clear_has_cgroup_mem_mount();
  return cgroup_mem_mount_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get());
}
inline void NsJailConfig::set_allocated_cgroup_mem_mount(::std::string* cgroup_mem_mount) {
  if (cgroup_mem_mount != NULL) {
    set_has_cgroup_mem_mount();
  } else {
    clear_has_cgroup_mem_mount();
  }
  cgroup_mem_mount_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get(), cgroup_mem_mount);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_mem_mount)
}

// optional string cgroup_mem_parent = 69 [default = "NSJAIL"];
inline bool NsJailConfig::has_cgroup_mem_parent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NsJailConfig::set_has_cgroup_mem_parent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NsJailConfig::clear_has_cgroup_mem_parent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NsJailConfig::clear_cgroup_mem_parent() {
  cgroup_mem_parent_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get());
  clear_has_cgroup_mem_parent();
}
inline const ::std::string& NsJailConfig::cgroup_mem_parent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_mem_parent)
  return cgroup_mem_parent_.GetNoArena();
}
inline void NsJailConfig::set_cgroup_mem_parent(const ::std::string& value) {
  set_has_cgroup_mem_parent();
  cgroup_mem_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_mem_parent)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroup_mem_parent(::std::string&& value) {
  set_has_cgroup_mem_parent();
  cgroup_mem_parent_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_mem_parent)
}
#endif
inline void NsJailConfig::set_cgroup_mem_parent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroup_mem_parent();
  cgroup_mem_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_mem_parent)
}
inline void NsJailConfig::set_cgroup_mem_parent(const char* value, size_t size) {
  set_has_cgroup_mem_parent();
  cgroup_mem_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_mem_parent)
}
inline ::std::string* NsJailConfig::mutable_cgroup_mem_parent() {
  set_has_cgroup_mem_parent();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_mem_parent)
  return cgroup_mem_parent_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get());
}
inline ::std::string* NsJailConfig::release_cgroup_mem_parent() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_mem_parent)
  if (!has_cgroup_mem_parent()) {
    return NULL;
  }
  clear_has_cgroup_mem_parent();
  return cgroup_mem_parent_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get());
}
inline void NsJailConfig::set_allocated_cgroup_mem_parent(::std::string* cgroup_mem_parent) {
  if (cgroup_mem_parent != NULL) {
    set_has_cgroup_mem_parent();
  } else {
    clear_has_cgroup_mem_parent();
  }
  cgroup_mem_parent_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get(), cgroup_mem_parent);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_mem_parent)
}

// optional uint64 cgroup_pids_max = 70 [default = 0];
inline bool NsJailConfig::has_cgroup_pids_max() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void NsJailConfig::set_has_cgroup_pids_max() {
  _has_bits_[1] |= 0x00200000u;
}
inline void NsJailConfig::clear_has_cgroup_pids_max() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void NsJailConfig::clear_cgroup_pids_max() {
  cgroup_pids_max_ = GOOGLE_ULONGLONG(0);
  clear_has_cgroup_pids_max();
}
inline ::google::protobuf::uint64 NsJailConfig::cgroup_pids_max() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_pids_max)
  return cgroup_pids_max_;
}
inline void NsJailConfig::set_cgroup_pids_max(::google::protobuf::uint64 value) {
  set_has_cgroup_pids_max();
  cgroup_pids_max_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_pids_max)
}

// optional string cgroup_pids_mount = 71 [default = "/sys/fs/cgroup/pids"];
inline bool NsJailConfig::has_cgroup_pids_mount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NsJailConfig::set_has_cgroup_pids_mount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NsJailConfig::clear_has_cgroup_pids_mount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NsJailConfig::clear_cgroup_pids_mount() {
  cgroup_pids_mount_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get());
  clear_has_cgroup_pids_mount();
}
inline const ::std::string& NsJailConfig::cgroup_pids_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_pids_mount)
  return cgroup_pids_mount_.GetNoArena();
}
inline void NsJailConfig::set_cgroup_pids_mount(const ::std::string& value) {
  set_has_cgroup_pids_mount();
  cgroup_pids_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_pids_mount)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroup_pids_mount(::std::string&& value) {
  set_has_cgroup_pids_mount();
  cgroup_pids_mount_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_pids_mount)
}
#endif
inline void NsJailConfig::set_cgroup_pids_mount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroup_pids_mount();
  cgroup_pids_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_pids_mount)
}
inline void NsJailConfig::set_cgroup_pids_mount(const char* value, size_t size) {
  set_has_cgroup_pids_mount();
  cgroup_pids_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_pids_mount)
}
inline ::std::string* NsJailConfig::mutable_cgroup_pids_mount() {
  set_has_cgroup_pids_mount();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_pids_mount)
  return cgroup_pids_mount_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get());
}
inline ::std::string* NsJailConfig::release_cgroup_pids_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_pids_mount)
  if (!has_cgroup_pids_mount()) {
    return NULL;
  }
  clear_has_cgroup_pids_mount();
  return cgroup_pids_mount_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get());
}
inline void NsJailConfig::set_allocated_cgroup_pids_mount(::std::string* cgroup_pids_mount) {
  if (cgroup_pids_mount != NULL) {
    set_has_cgroup_pids_mount();
  } else {
    clear_has_cgroup_pids_mount();
  }
  cgroup_pids_mount_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get(), cgroup_pids_mount);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_pids_mount)
}

// optional string cgroup_pids_parent = 72 [default = "NSJAIL"];
inline bool NsJailConfig::has_cgroup_pids_parent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NsJailConfig::set_has_cgroup_pids_parent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NsJailConfig::clear_has_cgroup_pids_parent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NsJailConfig::clear_cgroup_pids_parent() {
  cgroup_pids_parent_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get());
  clear_has_cgroup_pids_parent();
}
inline const ::std::string& NsJailConfig::cgroup_pids_parent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_pids_parent)
  return cgroup_pids_parent_.GetNoArena();
}
inline void NsJailConfig::set_cgroup_pids_parent(const ::std::string& value) {
  set_has_cgroup_pids_parent();
  cgroup_pids_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_pids_parent)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroup_pids_parent(::std::string&& value) {
  set_has_cgroup_pids_parent();
  cgroup_pids_parent_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_pids_parent)
}
#endif
inline void NsJailConfig::set_cgroup_pids_parent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroup_pids_parent();
  cgroup_pids_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_pids_parent)
}
inline void NsJailConfig::set_cgroup_pids_parent(const char* value, size_t size) {
  set_has_cgroup_pids_parent();
  cgroup_pids_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_pids_parent)
}
inline ::std::string* NsJailConfig::mutable_cgroup_pids_parent() {
  set_has_cgroup_pids_parent();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_pids_parent)
  return cgroup_pids_parent_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get());
}
inline ::std::string* NsJailConfig::release_cgroup_pids_parent() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_pids_parent)
  if (!has_cgroup_pids_parent()) {
    return NULL;
  }
  clear_has_cgroup_pids_parent();
  return cgroup_pids_parent_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get());
}
inline void NsJailConfig::set_allocated_cgroup_pids_parent(::std::string* cgroup_pids_parent) {
  if (cgroup_pids_parent != NULL) {
    set_has_cgroup_pids_parent();
  } else {
    clear_has_cgroup_pids_parent();
  }
  cgroup_pids_parent_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get(), cgroup_pids_parent);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_pids_parent)
}

// optional uint32 cgroup_net_cls_classid = 73 [default = 0];
inline bool NsJailConfig::has_cgroup_net_cls_classid() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void NsJailConfig::set_has_cgroup_net_cls_classid() {
  _has_bits_[1] |= 0x00080000u;
}
inline void NsJailConfig::clear_has_cgroup_net_cls_classid() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void NsJailConfig::clear_cgroup_net_cls_classid() {
  cgroup_net_cls_classid_ = 0u;
  clear_has_cgroup_net_cls_classid();
}
inline ::google::protobuf::uint32 NsJailConfig::cgroup_net_cls_classid() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_net_cls_classid)
  return cgroup_net_cls_classid_;
}
inline void NsJailConfig::set_cgroup_net_cls_classid(::google::protobuf::uint32 value) {
  set_has_cgroup_net_cls_classid();
  cgroup_net_cls_classid_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_net_cls_classid)
}

// optional string cgroup_net_cls_mount = 74 [default = "/sys/fs/cgroup/net_cls"];
inline bool NsJailConfig::has_cgroup_net_cls_mount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NsJailConfig::set_has_cgroup_net_cls_mount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NsJailConfig::clear_has_cgroup_net_cls_mount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NsJailConfig::clear_cgroup_net_cls_mount() {
  cgroup_net_cls_mount_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get());
  clear_has_cgroup_net_cls_mount();
}
inline const ::std::string& NsJailConfig::cgroup_net_cls_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_net_cls_mount)
  return cgroup_net_cls_mount_.GetNoArena();
}
inline void NsJailConfig::set_cgroup_net_cls_mount(const ::std::string& value) {
  set_has_cgroup_net_cls_mount();
  cgroup_net_cls_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_net_cls_mount)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroup_net_cls_mount(::std::string&& value) {
  set_has_cgroup_net_cls_mount();
  cgroup_net_cls_mount_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_net_cls_mount)
}
#endif
inline void NsJailConfig::set_cgroup_net_cls_mount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroup_net_cls_mount();
  cgroup_net_cls_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_net_cls_mount)
}
inline void NsJailConfig::set_cgroup_net_cls_mount(const char* value, size_t size) {
  set_has_cgroup_net_cls_mount();
  cgroup_net_cls_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_net_cls_mount)
}
inline ::std::string* NsJailConfig::mutable_cgroup_net_cls_mount() {
  set_has_cgroup_net_cls_mount();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_net_cls_mount)
  return cgroup_net_cls_mount_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get());
}
inline ::std::string* NsJailConfig::release_cgroup_net_cls_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_net_cls_mount)
  if (!has_cgroup_net_cls_mount()) {
    return NULL;
  }
  clear_has_cgroup_net_cls_mount();
  return cgroup_net_cls_mount_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get());
}
inline void NsJailConfig::set_allocated_cgroup_net_cls_mount(::std::string* cgroup_net_cls_mount) {
  if (cgroup_net_cls_mount != NULL) {
    set_has_cgroup_net_cls_mount();
  } else {
    clear_has_cgroup_net_cls_mount();
  }
  cgroup_net_cls_mount_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get(), cgroup_net_cls_mount);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_net_cls_mount)
}

// optional string cgroup_net_cls_parent = 75 [default = "NSJAIL"];
inline bool NsJailConfig::has_cgroup_net_cls_parent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NsJailConfig::set_has_cgroup_net_cls_parent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NsJailConfig::clear_has_cgroup_net_cls_parent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NsJailConfig::clear_cgroup_net_cls_parent() {
  cgroup_net_cls_parent_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get());
  clear_has_cgroup_net_cls_parent();
}
inline const ::std::string& NsJailConfig::cgroup_net_cls_parent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_net_cls_parent)
  return cgroup_net_cls_parent_.GetNoArena();
}
inline void NsJailConfig::set_cgroup_net_cls_parent(const ::std::string& value) {
  set_has_cgroup_net_cls_parent();
  cgroup_net_cls_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_net_cls_parent)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroup_net_cls_parent(::std::string&& value) {
  set_has_cgroup_net_cls_parent();
  cgroup_net_cls_parent_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_net_cls_parent)
}
#endif
inline void NsJailConfig::set_cgroup_net_cls_parent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroup_net_cls_parent();
  cgroup_net_cls_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_net_cls_parent)
}
inline void NsJailConfig::set_cgroup_net_cls_parent(const char* value, size_t size) {
  set_has_cgroup_net_cls_parent();
  cgroup_net_cls_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_net_cls_parent)
}
inline ::std::string* NsJailConfig::mutable_cgroup_net_cls_parent() {
  set_has_cgroup_net_cls_parent();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_net_cls_parent)
  return cgroup_net_cls_parent_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get());
}
inline ::std::string* NsJailConfig::release_cgroup_net_cls_parent() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_net_cls_parent)
  if (!has_cgroup_net_cls_parent()) {
    return NULL;
  }
  clear_has_cgroup_net_cls_parent();
  return cgroup_net_cls_parent_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get());
}
inline void NsJailConfig::set_allocated_cgroup_net_cls_parent(::std::string* cgroup_net_cls_parent) {
  if (cgroup_net_cls_parent != NULL) {
    set_has_cgroup_net_cls_parent();
  } else {
    clear_has_cgroup_net_cls_parent();
  }
  cgroup_net_cls_parent_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get(), cgroup_net_cls_parent);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_net_cls_parent)
}

// optional uint32 cgroup_cpu_ms_per_sec = 76 [default = 0];
inline bool NsJailConfig::has_cgroup_cpu_ms_per_sec() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void NsJailConfig::set_has_cgroup_cpu_ms_per_sec() {
  _has_bits_[1] |= 0x00400000u;
}
inline void NsJailConfig::clear_has_cgroup_cpu_ms_per_sec() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void NsJailConfig::clear_cgroup_cpu_ms_per_sec() {
  cgroup_cpu_ms_per_sec_ = 0u;
  clear_has_cgroup_cpu_ms_per_sec();
}
inline ::google::protobuf::uint32 NsJailConfig::cgroup_cpu_ms_per_sec() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_cpu_ms_per_sec)
  return cgroup_cpu_ms_per_sec_;
}
inline void NsJailConfig::set_cgroup_cpu_ms_per_sec(::google::protobuf::uint32 value) {
  set_has_cgroup_cpu_ms_per_sec();
  cgroup_cpu_ms_per_sec_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_cpu_ms_per_sec)
}

// optional string cgroup_cpu_mount = 77 [default = "/sys/fs/cgroup/cpu"];
inline bool NsJailConfig::has_cgroup_cpu_mount() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NsJailConfig::set_has_cgroup_cpu_mount() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NsJailConfig::clear_has_cgroup_cpu_mount() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NsJailConfig::clear_cgroup_cpu_mount() {
  cgroup_cpu_mount_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get());
  clear_has_cgroup_cpu_mount();
}
inline const ::std::string& NsJailConfig::cgroup_cpu_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_cpu_mount)
  return cgroup_cpu_mount_.GetNoArena();
}
inline void NsJailConfig::set_cgroup_cpu_mount(const ::std::string& value) {
  set_has_cgroup_cpu_mount();
  cgroup_cpu_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_cpu_mount)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroup_cpu_mount(::std::string&& value) {
  set_has_cgroup_cpu_mount();
  cgroup_cpu_mount_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_cpu_mount)
}
#endif
inline void NsJailConfig::set_cgroup_cpu_mount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroup_cpu_mount();
  cgroup_cpu_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_cpu_mount)
}
inline void NsJailConfig::set_cgroup_cpu_mount(const char* value, size_t size) {
  set_has_cgroup_cpu_mount();
  cgroup_cpu_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_cpu_mount)
}
inline ::std::string* NsJailConfig::mutable_cgroup_cpu_mount() {
  set_has_cgroup_cpu_mount();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_cpu_mount)
  return cgroup_cpu_mount_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get());
}
inline ::std::string* NsJailConfig::release_cgroup_cpu_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_cpu_mount)
  if (!has_cgroup_cpu_mount()) {
    return NULL;
  }
  clear_has_cgroup_cpu_mount();
  return cgroup_cpu_mount_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get());
}
inline void NsJailConfig::set_allocated_cgroup_cpu_mount(::std::string* cgroup_cpu_mount) {
  if (cgroup_cpu_mount != NULL) {
    set_has_cgroup_cpu_mount();
  } else {
    clear_has_cgroup_cpu_mount();
  }
  cgroup_cpu_mount_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get(), cgroup_cpu_mount);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_cpu_mount)
}

// optional string cgroup_cpu_parent = 78 [default = "NSJAIL"];
inline bool NsJailConfig::has_cgroup_cpu_parent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NsJailConfig::set_has_cgroup_cpu_parent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NsJailConfig::clear_has_cgroup_cpu_parent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NsJailConfig::clear_cgroup_cpu_parent() {
  cgroup_cpu_parent_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get());
  clear_has_cgroup_cpu_parent();
}
inline const ::std::string& NsJailConfig::cgroup_cpu_parent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_cpu_parent)
  return cgroup_cpu_parent_.GetNoArena();
}
inline void NsJailConfig::set_cgroup_cpu_parent(const ::std::string& value) {
  set_has_cgroup_cpu_parent();
  cgroup_cpu_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_cpu_parent)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroup_cpu_parent(::std::string&& value) {
  set_has_cgroup_cpu_parent();
  cgroup_cpu_parent_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_cpu_parent)
}
#endif
inline void NsJailConfig::set_cgroup_cpu_parent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroup_cpu_parent();
  cgroup_cpu_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_cpu_parent)
}
inline void NsJailConfig::set_cgroup_cpu_parent(const char* value, size_t size) {
  set_has_cgroup_cpu_parent();
  cgroup_cpu_parent_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_cpu_parent)
}
inline ::std::string* NsJailConfig::mutable_cgroup_cpu_parent() {
  set_has_cgroup_cpu_parent();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_cpu_parent)
  return cgroup_cpu_parent_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get());
}
inline ::std::string* NsJailConfig::release_cgroup_cpu_parent() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_cpu_parent)
  if (!has_cgroup_cpu_parent()) {
    return NULL;
  }
  clear_has_cgroup_cpu_parent();
  return cgroup_cpu_parent_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get());
}
inline void NsJailConfig::set_allocated_cgroup_cpu_parent(::std::string* cgroup_cpu_parent) {
  if (cgroup_cpu_parent != NULL) {
    set_has_cgroup_cpu_parent();
  } else {
    clear_has_cgroup_cpu_parent();
  }
  cgroup_cpu_parent_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get(), cgroup_cpu_parent);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_cpu_parent)
}

// optional string cgroupv2_mount = 79 [default = "/sys/fs/cgroup"];
inline bool NsJailConfig::has_cgroupv2_mount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NsJailConfig::set_has_cgroupv2_mount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NsJailConfig::clear_has_cgroupv2_mount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NsJailConfig::clear_cgroupv2_mount() {
  cgroupv2_mount_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_.get());
  clear_has_cgroupv2_mount();
}
inline const ::std::string& NsJailConfig::cgroupv2_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroupv2_mount)
  return cgroupv2_mount_.GetNoArena();
}
inline void NsJailConfig::set_cgroupv2_mount(const ::std::string& value) {
  set_has_cgroupv2_mount();
  cgroupv2_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroupv2_mount)
}
#if LANG_CXX11
inline void NsJailConfig::set_cgroupv2_mount(::std::string&& value) {
  set_has_cgroupv2_mount();
  cgroupv2_mount_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroupv2_mount)
}
#endif
inline void NsJailConfig::set_cgroupv2_mount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cgroupv2_mount();
  cgroupv2_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroupv2_mount)
}
inline void NsJailConfig::set_cgroupv2_mount(const char* value, size_t size) {
  set_has_cgroupv2_mount();
  cgroupv2_mount_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroupv2_mount)
}
inline ::std::string* NsJailConfig::mutable_cgroupv2_mount() {
  set_has_cgroupv2_mount();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroupv2_mount)
  return cgroupv2_mount_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_.get());
}
inline ::std::string* NsJailConfig::release_cgroupv2_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroupv2_mount)
  if (!has_cgroupv2_mount()) {
    return NULL;
  }
  clear_has_cgroupv2_mount();
  return cgroupv2_mount_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_.get());
}
inline void NsJailConfig::set_allocated_cgroupv2_mount(::std::string* cgroupv2_mount) {
  if (cgroupv2_mount != NULL) {
    set_has_cgroupv2_mount();
  } else {
    clear_has_cgroupv2_mount();
  }
  cgroupv2_mount_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_.get(), cgroupv2_mount);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroupv2_mount)
}

// optional bool use_cgroupv2 = 80 [default = false];
inline bool NsJailConfig::has_use_cgroupv2() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void NsJailConfig::set_has_use_cgroupv2() {
  _has_bits_[1] |= 0x01000000u;
}
inline void NsJailConfig::clear_has_use_cgroupv2() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void NsJailConfig::clear_use_cgroupv2() {
  use_cgroupv2_ = false;
  clear_has_use_cgroupv2();
}
inline bool NsJailConfig::use_cgroupv2() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.use_cgroupv2)
  return use_cgroupv2_;
}
inline void NsJailConfig::set_use_cgroupv2(bool value) {
  set_has_use_cgroupv2();
  use_cgroupv2_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.use_cgroupv2)
}

// optional bool iface_no_lo = 81 [default = false];
inline bool NsJailConfig::has_iface_no_lo() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void NsJailConfig::set_has_iface_no_lo() {
  _has_bits_[1] |= 0x02000000u;
}
inline void NsJailConfig::clear_has_iface_no_lo() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void NsJailConfig::clear_iface_no_lo() {
  iface_no_lo_ = false;
  clear_has_iface_no_lo();
}
inline bool NsJailConfig::iface_no_lo() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.iface_no_lo)
  return iface_no_lo_;
}
inline void NsJailConfig::set_iface_no_lo(bool value) {
  set_has_iface_no_lo();
  iface_no_lo_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.iface_no_lo)
}

// repeated string iface_own = 82;
inline int NsJailConfig::iface_own_size() const {
  return iface_own_.size();
}
inline void NsJailConfig::clear_iface_own() {
  iface_own_.Clear();
}
inline const ::std::string& NsJailConfig::iface_own(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.iface_own)
  return iface_own_.Get(index);
}
inline ::std::string* NsJailConfig::mutable_iface_own(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.iface_own)
  return iface_own_.Mutable(index);
}
inline void NsJailConfig::set_iface_own(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.iface_own)
  iface_own_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NsJailConfig::set_iface_own(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.iface_own)
  iface_own_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NsJailConfig::set_iface_own(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  iface_own_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.iface_own)
}
inline void NsJailConfig::set_iface_own(int index, const char* value, size_t size) {
  iface_own_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.iface_own)
}
inline ::std::string* NsJailConfig::add_iface_own() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.iface_own)
  return iface_own_.Add();
}
inline void NsJailConfig::add_iface_own(const ::std::string& value) {
  iface_own_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.iface_own)
}
#if LANG_CXX11
inline void NsJailConfig::add_iface_own(::std::string&& value) {
  iface_own_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.iface_own)
}
#endif
inline void NsJailConfig::add_iface_own(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  iface_own_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.iface_own)
}
inline void NsJailConfig::add_iface_own(const char* value, size_t size) {
  iface_own_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.iface_own)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NsJailConfig::iface_own() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.iface_own)
  return iface_own_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NsJailConfig::mutable_iface_own() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.iface_own)
  return &iface_own_;
}

// optional string macvlan_iface = 83;
inline bool NsJailConfig::has_macvlan_iface() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NsJailConfig::set_has_macvlan_iface() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NsJailConfig::clear_has_macvlan_iface() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NsJailConfig::clear_macvlan_iface() {
  macvlan_iface_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_macvlan_iface();
}
inline const ::std::string& NsJailConfig::macvlan_iface() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_iface)
  return macvlan_iface_.GetNoArena();
}
inline void NsJailConfig::set_macvlan_iface(const ::std::string& value) {
  set_has_macvlan_iface();
  macvlan_iface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_iface)
}
#if LANG_CXX11
inline void NsJailConfig::set_macvlan_iface(::std::string&& value) {
  set_has_macvlan_iface();
  macvlan_iface_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_iface)
}
#endif
inline void NsJailConfig::set_macvlan_iface(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_macvlan_iface();
  macvlan_iface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_iface)
}
inline void NsJailConfig::set_macvlan_iface(const char* value, size_t size) {
  set_has_macvlan_iface();
  macvlan_iface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_iface)
}
inline ::std::string* NsJailConfig::mutable_macvlan_iface() {
  set_has_macvlan_iface();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_iface)
  return macvlan_iface_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NsJailConfig::release_macvlan_iface() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_iface)
  if (!has_macvlan_iface()) {
    return NULL;
  }
  clear_has_macvlan_iface();
  return macvlan_iface_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NsJailConfig::set_allocated_macvlan_iface(::std::string* macvlan_iface) {
  if (macvlan_iface != NULL) {
    set_has_macvlan_iface();
  } else {
    clear_has_macvlan_iface();
  }
  macvlan_iface_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), macvlan_iface);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_iface)
}

// optional string macvlan_vs_ip = 84 [default = "192.168.0.2"];
inline bool NsJailConfig::has_macvlan_vs_ip() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NsJailConfig::set_has_macvlan_vs_ip() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NsJailConfig::clear_has_macvlan_vs_ip() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NsJailConfig::clear_macvlan_vs_ip() {
  macvlan_vs_ip_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get());
  clear_has_macvlan_vs_ip();
}
inline const ::std::string& NsJailConfig::macvlan_vs_ip() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_ip)
  return macvlan_vs_ip_.GetNoArena();
}
inline void NsJailConfig::set_macvlan_vs_ip(const ::std::string& value) {
  set_has_macvlan_vs_ip();
  macvlan_vs_ip_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_ip)
}
#if LANG_CXX11
inline void NsJailConfig::set_macvlan_vs_ip(::std::string&& value) {
  set_has_macvlan_vs_ip();
  macvlan_vs_ip_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_ip)
}
#endif
inline void NsJailConfig::set_macvlan_vs_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_macvlan_vs_ip();
  macvlan_vs_ip_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_ip)
}
inline void NsJailConfig::set_macvlan_vs_ip(const char* value, size_t size) {
  set_has_macvlan_vs_ip();
  macvlan_vs_ip_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_ip)
}
inline ::std::string* NsJailConfig::mutable_macvlan_vs_ip() {
  set_has_macvlan_vs_ip();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_ip)
  return macvlan_vs_ip_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get());
}
inline ::std::string* NsJailConfig::release_macvlan_vs_ip() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_ip)
  if (!has_macvlan_vs_ip()) {
    return NULL;
  }
  clear_has_macvlan_vs_ip();
  return macvlan_vs_ip_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get());
}
inline void NsJailConfig::set_allocated_macvlan_vs_ip(::std::string* macvlan_vs_ip) {
  if (macvlan_vs_ip != NULL) {
    set_has_macvlan_vs_ip();
  } else {
    clear_has_macvlan_vs_ip();
  }
  macvlan_vs_ip_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get(), macvlan_vs_ip);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_ip)
}

// optional string macvlan_vs_nm = 85 [default = "255.255.255.0"];
inline bool NsJailConfig::has_macvlan_vs_nm() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NsJailConfig::set_has_macvlan_vs_nm() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NsJailConfig::clear_has_macvlan_vs_nm() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NsJailConfig::clear_macvlan_vs_nm() {
  macvlan_vs_nm_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get());
  clear_has_macvlan_vs_nm();
}
inline const ::std::string& NsJailConfig::macvlan_vs_nm() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_nm)
  return macvlan_vs_nm_.GetNoArena();
}
inline void NsJailConfig::set_macvlan_vs_nm(const ::std::string& value) {
  set_has_macvlan_vs_nm();
  macvlan_vs_nm_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_nm)
}
#if LANG_CXX11
inline void NsJailConfig::set_macvlan_vs_nm(::std::string&& value) {
  set_has_macvlan_vs_nm();
  macvlan_vs_nm_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_nm)
}
#endif
inline void NsJailConfig::set_macvlan_vs_nm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_macvlan_vs_nm();
  macvlan_vs_nm_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_nm)
}
inline void NsJailConfig::set_macvlan_vs_nm(const char* value, size_t size) {
  set_has_macvlan_vs_nm();
  macvlan_vs_nm_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_nm)
}
inline ::std::string* NsJailConfig::mutable_macvlan_vs_nm() {
  set_has_macvlan_vs_nm();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_nm)
  return macvlan_vs_nm_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get());
}
inline ::std::string* NsJailConfig::release_macvlan_vs_nm() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_nm)
  if (!has_macvlan_vs_nm()) {
    return NULL;
  }
  clear_has_macvlan_vs_nm();
  return macvlan_vs_nm_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get());
}
inline void NsJailConfig::set_allocated_macvlan_vs_nm(::std::string* macvlan_vs_nm) {
  if (macvlan_vs_nm != NULL) {
    set_has_macvlan_vs_nm();
  } else {
    clear_has_macvlan_vs_nm();
  }
  macvlan_vs_nm_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get(), macvlan_vs_nm);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_nm)
}

// optional string macvlan_vs_gw = 86 [default = "192.168.0.1"];
inline bool NsJailConfig::has_macvlan_vs_gw() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NsJailConfig::set_has_macvlan_vs_gw() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NsJailConfig::clear_has_macvlan_vs_gw() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NsJailConfig::clear_macvlan_vs_gw() {
  macvlan_vs_gw_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get());
  clear_has_macvlan_vs_gw();
}
inline const ::std::string& NsJailConfig::macvlan_vs_gw() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_gw)
  return macvlan_vs_gw_.GetNoArena();
}
inline void NsJailConfig::set_macvlan_vs_gw(const ::std::string& value) {
  set_has_macvlan_vs_gw();
  macvlan_vs_gw_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_gw)
}
#if LANG_CXX11
inline void NsJailConfig::set_macvlan_vs_gw(::std::string&& value) {
  set_has_macvlan_vs_gw();
  macvlan_vs_gw_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_gw)
}
#endif
inline void NsJailConfig::set_macvlan_vs_gw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_macvlan_vs_gw();
  macvlan_vs_gw_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_gw)
}
inline void NsJailConfig::set_macvlan_vs_gw(const char* value, size_t size) {
  set_has_macvlan_vs_gw();
  macvlan_vs_gw_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_gw)
}
inline ::std::string* NsJailConfig::mutable_macvlan_vs_gw() {
  set_has_macvlan_vs_gw();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_gw)
  return macvlan_vs_gw_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get());
}
inline ::std::string* NsJailConfig::release_macvlan_vs_gw() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_gw)
  if (!has_macvlan_vs_gw()) {
    return NULL;
  }
  clear_has_macvlan_vs_gw();
  return macvlan_vs_gw_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get());
}
inline void NsJailConfig::set_allocated_macvlan_vs_gw(::std::string* macvlan_vs_gw) {
  if (macvlan_vs_gw != NULL) {
    set_has_macvlan_vs_gw();
  } else {
    clear_has_macvlan_vs_gw();
  }
  macvlan_vs_gw_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get(), macvlan_vs_gw);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_gw)
}

// optional string macvlan_vs_ma = 87 [default = ""];
inline bool NsJailConfig::has_macvlan_vs_ma() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NsJailConfig::set_has_macvlan_vs_ma() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NsJailConfig::clear_has_macvlan_vs_ma() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NsJailConfig::clear_macvlan_vs_ma() {
  macvlan_vs_ma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_macvlan_vs_ma();
}
inline const ::std::string& NsJailConfig::macvlan_vs_ma() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_ma)
  return macvlan_vs_ma_.GetNoArena();
}
inline void NsJailConfig::set_macvlan_vs_ma(const ::std::string& value) {
  set_has_macvlan_vs_ma();
  macvlan_vs_ma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_ma)
}
#if LANG_CXX11
inline void NsJailConfig::set_macvlan_vs_ma(::std::string&& value) {
  set_has_macvlan_vs_ma();
  macvlan_vs_ma_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_ma)
}
#endif
inline void NsJailConfig::set_macvlan_vs_ma(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_macvlan_vs_ma();
  macvlan_vs_ma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_ma)
}
inline void NsJailConfig::set_macvlan_vs_ma(const char* value, size_t size) {
  set_has_macvlan_vs_ma();
  macvlan_vs_ma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_ma)
}
inline ::std::string* NsJailConfig::mutable_macvlan_vs_ma() {
  set_has_macvlan_vs_ma();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_ma)
  return macvlan_vs_ma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NsJailConfig::release_macvlan_vs_ma() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_ma)
  if (!has_macvlan_vs_ma()) {
    return NULL;
  }
  clear_has_macvlan_vs_ma();
  return macvlan_vs_ma_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NsJailConfig::set_allocated_macvlan_vs_ma(::std::string* macvlan_vs_ma) {
  if (macvlan_vs_ma != NULL) {
    set_has_macvlan_vs_ma();
  } else {
    clear_has_macvlan_vs_ma();
  }
  macvlan_vs_ma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), macvlan_vs_ma);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_ma)
}

// optional string macvlan_vs_mo = 88 [default = "private"];
inline bool NsJailConfig::has_macvlan_vs_mo() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NsJailConfig::set_has_macvlan_vs_mo() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NsJailConfig::clear_has_macvlan_vs_mo() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NsJailConfig::clear_macvlan_vs_mo() {
  macvlan_vs_mo_.ClearToDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_mo_.get());
  clear_has_macvlan_vs_mo();
}
inline const ::std::string& NsJailConfig::macvlan_vs_mo() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_mo)
  return macvlan_vs_mo_.GetNoArena();
}
inline void NsJailConfig::set_macvlan_vs_mo(const ::std::string& value) {
  set_has_macvlan_vs_mo();
  macvlan_vs_mo_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_mo_.get(), value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_mo)
}
#if LANG_CXX11
inline void NsJailConfig::set_macvlan_vs_mo(::std::string&& value) {
  set_has_macvlan_vs_mo();
  macvlan_vs_mo_.SetNoArena(
    &::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_mo_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_mo)
}
#endif
inline void NsJailConfig::set_macvlan_vs_mo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_macvlan_vs_mo();
  macvlan_vs_mo_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_mo_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_mo)
}
inline void NsJailConfig::set_macvlan_vs_mo(const char* value, size_t size) {
  set_has_macvlan_vs_mo();
  macvlan_vs_mo_.SetNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_mo_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_mo)
}
inline ::std::string* NsJailConfig::mutable_macvlan_vs_mo() {
  set_has_macvlan_vs_mo();
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_mo)
  return macvlan_vs_mo_.MutableNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_mo_.get());
}
inline ::std::string* NsJailConfig::release_macvlan_vs_mo() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_mo)
  if (!has_macvlan_vs_mo()) {
    return NULL;
  }
  clear_has_macvlan_vs_mo();
  return macvlan_vs_mo_.ReleaseNonDefaultNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_mo_.get());
}
inline void NsJailConfig::set_allocated_macvlan_vs_mo(::std::string* macvlan_vs_mo) {
  if (macvlan_vs_mo != NULL) {
    set_has_macvlan_vs_mo();
  } else {
    clear_has_macvlan_vs_mo();
  }
  macvlan_vs_mo_.SetAllocatedNoArena(&::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_mo_.get(), macvlan_vs_mo);
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_mo)
}

// optional int32 nice_level = 89 [default = 19];
inline bool NsJailConfig::has_nice_level() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void NsJailConfig::set_has_nice_level() {
  _has_bits_[2] |= 0x00100000u;
}
inline void NsJailConfig::clear_has_nice_level() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void NsJailConfig::clear_nice_level() {
  nice_level_ = 19;
  clear_has_nice_level();
}
inline ::google::protobuf::int32 NsJailConfig::nice_level() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.nice_level)
  return nice_level_;
}
inline void NsJailConfig::set_nice_level(::google::protobuf::int32 value) {
  set_has_nice_level();
  nice_level_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.nice_level)
}

// optional .nsjail.Exe exec_bin = 90;
inline bool NsJailConfig::has_exec_bin() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NsJailConfig::set_has_exec_bin() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NsJailConfig::clear_has_exec_bin() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NsJailConfig::clear_exec_bin() {
  if (exec_bin_ != NULL) exec_bin_->Clear();
  clear_has_exec_bin();
}
inline const ::nsjail::Exe& NsJailConfig::_internal_exec_bin() const {
  return *exec_bin_;
}
inline const ::nsjail::Exe& NsJailConfig::exec_bin() const {
  const ::nsjail::Exe* p = exec_bin_;
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.exec_bin)
  return p != NULL ? *p : *reinterpret_cast<const ::nsjail::Exe*>(
      &::nsjail::_Exe_default_instance_);
}
inline ::nsjail::Exe* NsJailConfig::release_exec_bin() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.exec_bin)
  clear_has_exec_bin();
  ::nsjail::Exe* temp = exec_bin_;
  exec_bin_ = NULL;
  return temp;
}
inline ::nsjail::Exe* NsJailConfig::mutable_exec_bin() {
  set_has_exec_bin();
  if (exec_bin_ == NULL) {
    auto* p = CreateMaybeMessage<::nsjail::Exe>(GetArenaNoVirtual());
    exec_bin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.exec_bin)
  return exec_bin_;
}
inline void NsJailConfig::set_allocated_exec_bin(::nsjail::Exe* exec_bin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete exec_bin_;
  }
  if (exec_bin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      exec_bin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, exec_bin, submessage_arena);
    }
    set_has_exec_bin();
  } else {
    clear_has_exec_bin();
  }
  exec_bin_ = exec_bin;
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.exec_bin)
}

// optional bool disable_tsc = 93 [default = false];
inline bool NsJailConfig::has_disable_tsc() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void NsJailConfig::set_has_disable_tsc() {
  _has_bits_[1] |= 0x04000000u;
}
inline void NsJailConfig::clear_has_disable_tsc() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void NsJailConfig::clear_disable_tsc() {
  disable_tsc_ = false;
  clear_has_disable_tsc();
}
inline bool NsJailConfig::disable_tsc() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.disable_tsc)
  return disable_tsc_;
}
inline void NsJailConfig::set_disable_tsc(bool value) {
  set_has_disable_tsc();
  disable_tsc_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.disable_tsc)
}

// optional bool forward_signals = 94 [default = false];
inline bool NsJailConfig::has_forward_signals() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void NsJailConfig::set_has_forward_signals() {
  _has_bits_[1] |= 0x10000000u;
}
inline void NsJailConfig::clear_has_forward_signals() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void NsJailConfig::clear_forward_signals() {
  forward_signals_ = false;
  clear_has_forward_signals();
}
inline bool NsJailConfig::forward_signals() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.forward_signals)
  return forward_signals_;
}
inline void NsJailConfig::set_forward_signals(bool value) {
  set_has_forward_signals();
  forward_signals_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.forward_signals)
}

// optional bool detect_cgroupv2 = 95 [default = false];
inline bool NsJailConfig::has_detect_cgroupv2() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void NsJailConfig::set_has_detect_cgroupv2() {
  _has_bits_[1] |= 0x20000000u;
}
inline void NsJailConfig::clear_has_detect_cgroupv2() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void NsJailConfig::clear_detect_cgroupv2() {
  detect_cgroupv2_ = false;
  clear_has_detect_cgroupv2();
}
inline bool NsJailConfig::detect_cgroupv2() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.detect_cgroupv2)
  return detect_cgroupv2_;
}
inline void NsJailConfig::set_detect_cgroupv2(bool value) {
  set_has_detect_cgroupv2();
  detect_cgroupv2_ = value;
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.detect_cgroupv2)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nsjail

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nsjail::Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsjail::Mode>() {
  return ::nsjail::Mode_descriptor();
}
template <> struct is_proto_enum< ::nsjail::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsjail::LogLevel>() {
  return ::nsjail::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::nsjail::RLimit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsjail::RLimit>() {
  return ::nsjail::RLimit_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_config_2eproto
